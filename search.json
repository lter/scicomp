[
  {
    "objectID": "tutorial-scaffold_quarto-website.html",
    "href": "tutorial-scaffold_quarto-website.html",
    "title": "LTER Scientific Computing Team",
    "section": "",
    "text": "Quarto is a new tool developed by RStudio (the company, not the program) to create a more ‘what you see is what you get’ editor for creating markdown files and products (e.g., books, websites, etc.). Additionally, it includes a visual editor that allows users to insert headings and embed figures via buttons that are intuitively labeled rather than through somewhat arcane HTML text or symbols. While Quarto is still in its infancy, it is rapidly gathering a following due to the aforementioned visual editor and for the ease with which quarto documents and websites can be created.\n\nPrerequisites\nTo follow along with this tutorial you will need to take the following steps:\n\nDo all of the pre-workshop steps relevant to our “Collaborative Coding with GitHub” workshop\nDownload Quarto\n\nFeel free to skip any steps that you have already completed!\n\n\nCreate a Quarto Website R Project\nTo begin, click the “Project” button in the top right of your RStudio session.\n\nIn the resulting dialogue, click the “New Directory” option.\n\n\n\nFrom the list of options for project templates, select “Quarto Website”.\n\n\n\nPick a title and check the “Create a git repository” checkbox. For your title, short but descriptive titles are most effective. Once that is done, click “Create Project” in the bottom right of the window.\n\n\n\nAfter a few seconds, RStudio should refresh with a Quarto document (such documents have the file extension “.qmd”) and a “_quarto.yml” file open.\n\n\n\nPart of Quarto’s central philosophy is that all of the formatting of individual .qmd files in a project is governed by the settings created by a singular .yml file. In an R markdown project some of the global settings are set in .yml but other settings are handled within each .Rmd file. This centralization is a key innovation in streamlining projects and is one reason for Quarto’s quick popularity.\n\n\nPreparing Project for Web Deployment\nTo prepare your project for web deployment via GitHub Pages, we have three quick steps that we must first complete.\nFirst, in the “_quarto.yml” file, add output-dir: docs as a subheading beneath the project: heading. Make sure that the indentation is the same as the type: website but the new line can be either above or below that line.\n\n\n\nSecond, in the “Terminal” pane run touch .nojekyll. This creates a file called “.nojekyll” that is necessary for hosting your website via GitHub Pages.\nThird, in the “Terminal” pane run quarto render. This processes the template .qmd files you currently have in the repository and prepares them to become actual web pages.\nOnce you’ve done these three things you can move on to creating a GitHub repository so that we can take the necessary steps to having GitHub host your website!\n\n\nMake a New GitHub Repository\nFrom your GitHub “Repositories” tab, click the  green  “New” button.\n\nAdd a title to your repository and add a description. Once you’ve added these two things, scroll down and click the  green  “Create repository” button.\n\n\n\nBe sure that you do not add a README, do not add a gitignore, and do not add a license. Adding any of these three will cause a merge conflict when we link the project that you just created with the GitHub repository that you are in the process of creating.\n\n\n\nAfter a few seconds you should be placed on your new repository’s landing page which will look like the below image because there isn’t anything in your repository (yet).\nCopy the link in the field and go back to your RStudio session.\n\n\n\n\n\nAdding your Project to GitHub\nThe following steps include a sequence of command line operations that will be relayed in code chunks below. Unless otherwise stated, all of the following code should be run in “Terminal”.\nIf you didn’t check the “Create a git repository” button while creating the R project, you’ll need to do that via the command line now. If you did check that box, you should skip this step!\n\n# Start a git repository on the \"main\" branch\ngit init -b main\n\nStage all of the files in your project to the git repository. This includes the .yml file, all .qmd files and all of their rendered versions created when you ran quarto render earlier. This code is equivalent to checking the box for the files in the “Git” pane of RStudio.\n\n# Stage all files\ngit add .\n\nOnce everything has been staged, you now must commit those staged files with a message.\n\n# Commit all files with the message in quotes\ngit commit -m \"Initial commit\"\n\nNow that your project files have been committed, you need to tell your computer where you will be pushing to and pulling from. Paste the link you copied at the end of the “Make a New GitHub Repository” into the code shown in the chunk below (instead of GITHUB_URL) and run it.\n\n# Tell your computer which GitHub repository to connect to\ngit remote add origin GITHUB_URL\n\nVerify that URL before continuing.\n\n# Confirm that URL worked\ngit remote -v\n\nFinally, push your commited changes to the repostory that you set as the remote in the preceding two steps.\n\n# Push all of the content to the main branch\ngit push -u origin main\n\nNow, go back to GitHub and refresh the page to see your project content safe and sound in your new GitHub repository!\n\n\n\nDeploy Website via GitHub\nIn order to get your new website actually on the web, we’ll need to tell GitHub that we want our website to be accessible at a .github.io URL.\nTo do this, go to the “Settings” tab with a gear icon and click it. You may be prompted to re-enter your GitHub password, do so and you can proceed.\n\nIn the resulting page, look towards the bottom of the left sidebar of settings categories and click the “Pages” option. This is at the very bottom of the sidebar in the screen capture below but is towards the middle of all of the settings categories Github offers you.\n\nScroll down to the middle of this page and where it says “Branch” click the dropdown menu that says “None” by default.\n\nSelect “main” from the dropdown.\n\n\n\nThis opens up a new dropdown menu where you can select which folder in your repository contains your website’s content (it defaults to “/ (root)”). Because we specified output-dir: docs in the .yml file earlier we can select “/docs” from the dropdown menu.\n\n\n\nOnce you’ve told GitHub that you want a website generated from the “docs” folder on the main branch, click the “Save” button.\n\n\n\nFrom this moment your website has begun being deployed by GitHub! You can check the status of the building process by navigating to the “Actions” tab of your repository.\nSelect the “pages build and deployment workflow” in the list of workflows on the bottom righthand side of the page.\n\nThis shows you GitHub’s building and deployment process as a flowchart. While it is working on each step there will be an amber circle next to the name of that sub-task. When a sub-task is completed, the amber circle becomes a green circle with a check mark.\n\nWhen the three steps are complete the amber clock symbol next to the “pages build and deployment” action will turn into a larger green circle with a check mark. This is GitHub’s way of telling you that your website is live and accessible to anyone on the internet.\n\nYou can now visit your website by visiting its dedicated URL. This URL can be found by returning to the “Settings” tab and then scrolling through the sidebar to the “Pages” section.\nAlternately, the website for your repository always uses the following composition: https://repository owner.github.io/repository name/\n\nIf we visit that link, we can see that our website is live!\n\n\nGitHub Housekeeping\nWe recommend a quick housekeeping step now to make it easier to find this URL in the future. Copy the URL from the Pages setting area and return to the “Code” tab of the repository.\nOnce there, click the small gear icon to the right of the “About” header.\n\nIn the resulting window, paste the copied URL into the “Website” field. Once you’ve pasted it in, click the green “Save changes” button.\n\n\n\nThis places the link to your deployed website in an intuitive, easy-to-find location both for interested third parties and yourself in the future.\n\n\n\n\nAdding Website Content\nNow that you have a live website you can build whatever you’d like! Given the wide range of possibility, we’ll only cover how to add a new page but the same process applies to any edit to the living webpage.\nTo add a new page create a new Quarto document. You can do this by going to the “File” menu, entering the “New File” options, and selecting “Quarto Document…”\n\n\n\nSimilarly to an R markdown file, this will open a new window that lets you enter a title and author as well as decide what format you want to render files to along with some other settings options. You only need to click the “Create” button in the bottom right of this dialogue (though you can definitely play with the other options and text boxes as you desire).\n\n\n\nAfter a moment, a new .qmd file will open in Quarto’s visual editor. For the purposes of this tutorial, you only need to add a title in the top of the file but for a real website you can add whatever content sparks joy for you!\n\n\n\nSave that file into your project folder. Its name can be anything but be sure that you remember what you name it!\n\n\n\nAdd the name of the new Quarto document to the .yml file in the website navbar area (in this example the file is called “more-stuff.qmd”).\n\n\n\nOnce you’ve added the file to the fundamental architecture of your website, you need to tell Quarto to re-build the part of the website that GitHub looks for when it deploys. To do this run quarto render in the Terminal.\nIf you want to preview your changes, run quarto preview in the Terminal and a new browser window will be displayed showing your current website content. This preview continues until you click the red stop sign icon in RStudio so be sure to end it when you’re done with the preview!\n\nRegardless, once you’ve run either quarto render or quarto preview you need to stage and commit all changed files indicated in the Git pane of RStudio. As a reminder, to stage files you check the box next to them, to commit staged files, type an informative message and press the “Commit” button in the right side of the window.\n\nSwitch back to GitHub and you’ll see an amber dot next to the commit hash just beneath and to the left of the green “Code” button.\n\nWhen the amber dot turns into a green check mark that means that your edits to your website are now included in the live version of your site!\n\nWhen you visit your website you may need to refresh the page for your edits to appear but all new visitors will see the updated content when they load the page.\n\n\n\nSupplementary Information\nQuarto is developing at a rapid pace so quality of life changes and new functionalities are introduced relatively frequently. Additionally, Quarto supports user-created “extensions” that can be downloaded in a given project and then used (similar to the way user-developed R packages can be shared) so if you want to do something that Quarto itself doesn’t support, chances are you’ll be able to find an extension that handles it.\nQuarto’s documentation of website creation and formatting is extremely thorough and is a great resource as you become more comfortable with your new website. We hope this tutorial was useful to you and welcome constructively critical feedback! Please post an issue with any thoughts for improvement that you have."
  },
  {
    "objectID": "shiny-server.html",
    "href": "shiny-server.html",
    "title": "Deploy Shiny Apps",
    "section": "",
    "text": "Note\n\n\n\nPlease note that the following instructions for deploying Shiny apps are meant to serve as internal documentation and will only work if you have sudo power on the SciComp team’s Shiny server.\nFeel free to contact us if you have a LTER-related Shiny app that you would like to deploy on our server!\nSciComp team members can deploy LTER-related Shiny apps on our server at: https://shiny.lternet.edu/\nTo deploy your working app, first make sure that all the files live at a GitHub repository. Once our sysadmin Nick Outin has made you an account on the server, you can log in via SSH."
  },
  {
    "objectID": "shiny-server.html#log-in",
    "href": "shiny-server.html#log-in",
    "title": "Deploy Shiny Apps",
    "section": "Log In",
    "text": "Log In\nFor Mac users, open the Terminal app and type the following command, replacing &lt;YOUR-USERNAME&gt; with your own username.\n\nssh &lt;YOUR-USERNAME&gt;@shiny.lternet.edu\n\nWindows users can log in with PuTTY, using shiny.lternet.edu as the host name.\nCheck out NCEAS’ guide to using SSH for additional help."
  },
  {
    "objectID": "shiny-server.html#set-up-proper-permissions",
    "href": "shiny-server.html#set-up-proper-permissions",
    "title": "Deploy Shiny Apps",
    "section": "Set Up Proper Permissions",
    "text": "Set Up Proper Permissions\n\nJoin shiny-apps\nA shiny-apps user group has been created in this server. Set up the proper permissions for your account by adding yourself to this group with this command.\n\nsudo usermod -aG shiny-apps &lt;YOUR-USERNAME&gt;\n\nTo decipher this command a bit: sudo will enable you to run commands as a user with full control and privileges. The usermod command is used to modify user account details. The basic syntax is:\n\nusermod [OPTIONS] &lt;YOUR-USERNAME&gt;\n\nThe -G option will add the user to a supplementary group. The -aG combined options will add the user to the new supplementary group while also leaving them in the other supplementary group(s) they were already a part of.\n\n\n\n\n\n\nNote\n\n\n\nAs an FYI, the apps on the server will run as the user shiny, so shiny is also in the shiny-apps user group.\n\n\n\n\nAllow Access to Your Home Directory\nAdditionally, you need to allow shiny access to your user home directory by running:\n\nsudo chmod a+x /home/&lt;YOUR-USERNAME&gt;\n\nThis chmod (change mode) command is used to control file permissions. Basic syntax:\n\nchmod [OPTIONS] MODE FILE/DIRECTORY\n\nThere are two “modes” that you can use to set permissions: Symbolic and Octal mode. The Symbolic mode uses operators and letters. For example, the a option denotes all the owner/groups the file/directory belongs to. The + operator grants the permission, and the letter x stands for the execute permission."
  },
  {
    "objectID": "shiny-server.html#tell-git-who-you-are",
    "href": "shiny-server.html#tell-git-who-you-are",
    "title": "Deploy Shiny Apps",
    "section": "Tell git Who You Are",
    "text": "Tell git Who You Are\nNow that your account has the proper permissions, use the git config commands to tell git who you are.\n\ngit config --global user.name \"&lt;YOUR-GITHUB-USERNAME&gt;\"\ngit config --global user.email \"&lt;YOUR-GITHUB-EMAIL&gt;\"\n\nReplace &lt;YOUR-GITHUB-USERNAME&gt; and &lt;YOUR-GITHUB-EMAIL&gt; with your own credentials. You can check to see if you entered your details correctly by entering git config --list."
  },
  {
    "objectID": "shiny-server.html#copy-your-app-to-the-server",
    "href": "shiny-server.html#copy-your-app-to-the-server",
    "title": "Deploy Shiny Apps",
    "section": "Copy Your App to the Server",
    "text": "Copy Your App to the Server\nThe easiest way to get all the files for your app to the server is by git clone.\nIf you like, you can create a folder named “github” to store all your future apps. For example, in the screenshot below, I created a “github” folder using the mkdir command in my home directory.\nTo check that the folder was created, I can list all the files/folders in my current directory with ls. Since I want my app to be inside the “github” folder, I used the cd command to change into that directory.\nFinally, git clone the GitHub repo that has all the files for your app. Here, I am cloning the lterpalettefinder-shiny repo to my local directory on the virtual machine as lterpalettefinder.\n\n\n\n\n\n\n\nTip\n\n\n\nYou can go one level above the current directory by typing cd .."
  },
  {
    "objectID": "shiny-server.html#install-necessary-r-packages",
    "href": "shiny-server.html#install-necessary-r-packages",
    "title": "Deploy Shiny Apps",
    "section": "Install Necessary R Packages",
    "text": "Install Necessary R Packages\nAfter you cloned the repository for your app, you can start installing the necessary R packages! To make these packages available for all users, you will want to execute commands with the root user’s privileges by typing the sudo -i command. Then open R by simply typing “R” and install packages with the usual install.packages() function.\n\n\nMissing Dependencies?\nIf you run into an error installing a R package, it’s likely because the server does not have the required dependencies installed yet.\nFor example, I wanted to install the lterpalettefinder R package, but I got lots of errors on missing dependencies instead.\n\nI saw that the curl dependency was missing, so I attempted to install that. However, R gives me another error.\n\nLooking closer, it asks me to install libcurl4-openssl-dev first. To install this Ubuntu package, I exited R with q() and logged off root with exit. Once I’m back in my own user profile, I can use the sudo apt install command to install libcurl4-openssl-dev.\n\nIf you get these prompts to restart services, you can tap Return/Enter to continue the installation.\n\n\nAfterwards, libcurl4-openssl-dev installed successfully, and then I can finally install the missing curl dependency in R!\n\nYou can repeat a similar process to find and install the rest of the required dependencies before you are able to install certain R packages."
  },
  {
    "objectID": "shiny-server.html#symlink-to-deployed-folder",
    "href": "shiny-server.html#symlink-to-deployed-folder",
    "title": "Deploy Shiny Apps",
    "section": "Symlink to Deployed Folder",
    "text": "Symlink to Deployed Folder\nSince all the Shiny apps are located under /srv/shiny-server/, how can we deploy the app we have in our local directory? We can create a symlink (symbolic link) between the local directory and /srv/shiny-server/. A symlink is essentially a pointer to other folders.\nCreate the link by running this command:\n\nsudo ln -s &lt;LOCAL-DIRECTORY-OF-APP&gt; &lt;SHINY-SERVER-DIRECTORY-OF-APP&gt;\n\nReplace &lt;LOCAL-DIRECTORY-OF-APP&gt; with your own directory and replace &lt;SHINY-SERVER-DIRECTORY-OF-APP&gt; with the file path of where you would like your app to deploy.\nFor example, the actual lterpalettefinder app lives under my home directory, but it needs to be deployed under /srv/shiny-server/, so I ran this command to link the two:\n\nNow /srv/shiny-server/lterpalettefinder points to /home/anchen/github/lterpalettefinder!\nYou can check the current symlinks by navigating to /srv/shiny-server/ and typing ls -l.\n\n\n\n\n\n\nNote\n\n\n\nThe name of the deployed folder corresponds to the URL: https://shiny.lternet.edu/&lt;YOUR-APP&gt;/"
  },
  {
    "objectID": "shiny-server.html#debug-app-and-check-its-live-link",
    "href": "shiny-server.html#debug-app-and-check-its-live-link",
    "title": "Deploy Shiny Apps",
    "section": "Debug App and Check its Live Link",
    "text": "Debug App and Check its Live Link\nIf everything goes right, your app will be live at https://shiny.lternet.edu/&lt;YOUR-APP&gt;/! If not, don’t worry and try troubleshooting what went wrong. Remember to check file paths and required R packages."
  },
  {
    "objectID": "wg_team-coding.html",
    "href": "wg_team-coding.html",
    "title": "Team Coding: 5 Essentials",
    "section": "",
    "text": "Have you ever had trouble running someone else’s code or re-running your own old code? Working in a synthesis group can bring up challenges like these as members try to run workflows written by others or written by themselves at the last in-person meeting months ago. To make the process easier and more reproducible, here is a list of our top 5 best practices to follow as you collaborate on scripts that address your group’s scientific questions. These are merely suggestions but we hope that they help facilitate seamless synthesis science!"
  },
  {
    "objectID": "wg_team-coding.html#prioritize-future-you",
    "href": "wg_team-coding.html#prioritize-future-you",
    "title": "Team Coding: 5 Essentials",
    "section": "1. Prioritize ‘Future You’",
    "text": "1. Prioritize ‘Future You’\nIf something takes more time now but will work better in the long run, invest the time now to save yourself heartache in the future. This can apply to taking the time to make a document listing the scripts in a given workflow, adding descriptive comments in an existing script, and many other contexts. By investing this time now, you will save ‘future you’ from unnecessary labor."
  },
  {
    "objectID": "wg_team-coding.html#always-leave-comments",
    "href": "wg_team-coding.html#always-leave-comments",
    "title": "Team Coding: 5 Essentials",
    "section": "2. Always Leave Comments",
    "text": "2. Always Leave Comments\nLeave enough comments in your code so that other members of your team (and ‘future you’!) can understand what your script does. This is a crucial habit that will benefit you immensely. By making your code more human-readable, you open the door for improved communication among team members. This makes it easier for people who weren’t involved in your workflow to jump in and give feedback if necessary or to onboard new team members who join later in the project. Plus, it is less of a hassle to edit and maintain well-commented code in the future; you can make changes without spending too much time deciphering each line of code."
  },
  {
    "objectID": "wg_team-coding.html#use-relative-file-paths",
    "href": "wg_team-coding.html#use-relative-file-paths",
    "title": "Team Coding: 5 Essentials",
    "section": "3. Use Relative File Paths",
    "text": "3. Use Relative File Paths\nWhen coding collaboratively, accounting for the difference between your folder structure and those of your colleagues becomes critical. For example, if you read in a data file using its absolute file path (e.g. “/users/my_name/documents/project/data/raw_data/example.csv”), only you will be able to successfully run that line of code and–by extension–your entire script! Also, the slashes between folder names are different depending on each person’s computer operating system, which means even a relative file path will only work for your teammates that share your computer brand.\nIf you’re an R user, there are two quick things you can do in your code to avoid these problems:\n\nRelative Paths – Use the dir.create function in your script to create any necessary folders.\nNeed a data folder? Use dir.create(\"data\") and you’ll create an empty data folder. Anyone else running your code will create the same folder and you can safely assume that part of the file path going forward.\n\n\nOperating System Differences – Use the file.path function with folder names without slashes.\nReading in data? Use file.path(\"data\", \"raw_data\", \"site_a.csv\") and file.path will automatically sense the computer’s operating system and insert the correct slashes for each user.\nFor example, if you are already working in the directory called “project”, then you can access example.csv using this relative file path: data/raw_data/example.csv. You can improve beyond even that by using the file.path function to automatically detect the computer operating system and insert the correct slash for you and anyone else running the code. We recommend using this function and assigning your file path to an object so you can use it anytime.\n\nmy_path &lt;- file.path(\"data\", \"raw_data\")\nmy_raw_data &lt;- read.csv(file = file.path(my_path, \"example.csv\"))"
  },
  {
    "objectID": "wg_team-coding.html#store-raw-data-in-the-cloud",
    "href": "wg_team-coding.html#store-raw-data-in-the-cloud",
    "title": "Team Coding: 5 Essentials",
    "section": "4. Store Raw Data in the Cloud",
    "text": "4. Store Raw Data in the Cloud\nIf you’re a GitHub user, you may be tempted to store your data files there, but GitHub limits the size of files allowed in repositories. Adding files larger than 50MB will receive a warning, and files larger than 100MB will be blocked. If you’re working with big datasets or spatial data, you can exceed this limit pretty fast.\nTo avoid this, we recommend instead that you store your raw data files in the cloud and make them available to everyone in your group. For example, you can create a folder for raw data in a Shared Google Drive (which we can create for you!). Then, you can download the data using the googledrive R package or with any other Google Drive API in your preferred language."
  },
  {
    "objectID": "wg_team-coding.html#meta-document",
    "href": "wg_team-coding.html#meta-document",
    "title": "Team Coding: 5 Essentials",
    "section": "5. Meta-Document",
    "text": "5. Meta-Document\nDocumenting every individual script is important, but it’s also well worth the time and effort to document the big picture of your workflow. As you continue to build on your workflow, it can be hard to keep track of each script’s role and how they relate to each other. You might need to update a script upstream and then try to figure out what other scripts downstream need to be updated next in order to account for the new edits. If you’re not using a workflow management software, then it’s best to thoroughly document how each script fits into the larger workflow. The README is a great place to document each step along the way.\n\n\n\nRegal Fritillary on Milkweed, Konza Prairie Biological Station - Photographer: Jill Haukos"
  },
  {
    "objectID": "portfolio.html",
    "href": "portfolio.html",
    "title": "Portfolio",
    "section": "",
    "text": "Working groups have often asked our team to synthesize and wrangle data from various heterogeneous datasets. For example, the Plant Reproduction working group had their own plant species data that they compiled from literature and expert knowledge. To get more data, we pulled from the TRY plant trait database and wrangled the dataset. After fixing the TRY column headers, values and units, we combined synonymous columns together with the working group’s original dataset. We ended up with a comprehensive, tidy dataset that covered over 100 plant species.\nIn another example, the Soil Phosphorus working group had gathered a bunch of soil nutrient datasets that all had different column headers and units. To combine these datasets together, we standardized the column headers via a data key, which consisted of a spreadsheet connecting the old column names to the new combined column names. Then we were able to synthesize the separate csv files into one master dataset.\nData synthesizing remains one of our most popular requests so please do not hesitate to reach out to us if we can help with this task, no matter how big or small."
  },
  {
    "objectID": "portfolio.html#data-synthesizing",
    "href": "portfolio.html#data-synthesizing",
    "title": "Portfolio",
    "section": "",
    "text": "Working groups have often asked our team to synthesize and wrangle data from various heterogeneous datasets. For example, the Plant Reproduction working group had their own plant species data that they compiled from literature and expert knowledge. To get more data, we pulled from the TRY plant trait database and wrangled the dataset. After fixing the TRY column headers, values and units, we combined synonymous columns together with the working group’s original dataset. We ended up with a comprehensive, tidy dataset that covered over 100 plant species.\nIn another example, the Soil Phosphorus working group had gathered a bunch of soil nutrient datasets that all had different column headers and units. To combine these datasets together, we standardized the column headers via a data key, which consisted of a spreadsheet connecting the old column names to the new combined column names. Then we were able to synthesize the separate csv files into one master dataset.\nData synthesizing remains one of our most popular requests so please do not hesitate to reach out to us if we can help with this task, no matter how big or small."
  },
  {
    "objectID": "portfolio.html#spatial-analyses-wrangling",
    "href": "portfolio.html#spatial-analyses-wrangling",
    "title": "Portfolio",
    "section": "Spatial Analyses & Wrangling",
    "text": "Spatial Analyses & Wrangling\nOur team has been instrumental in acquiring, wrangling, and summarizing spatial data. For the Silica Exports working group we developed a workflow (see here) that accomplishes the following tasks:\n\nCreates shapefiles that identify the drainage basin linked to several hundred stream gages\n“Cookie cuts” spatial data within those drainage basins (e.g., land cover, lithology, precipitation, etc.)\nSummarizes that extracted data both as rasters and as data tables for use as explanatory variables in other analyses\n\nWe are comfortable working with such data and can help your team acquire and/or process spatial data if that is of interest!"
  },
  {
    "objectID": "portfolio.html#figures-for-publication",
    "href": "portfolio.html#figures-for-publication",
    "title": "Portfolio",
    "section": "Figures for Publication",
    "text": "Figures for Publication\nAdditionally, our team is available to help your group create visualizations for publications! We have generated many figures for the Plant Reproduction working group’s paper on mast seeding synchrony using ggplot. Please feel free to reach out to us for help on visualizations when your team has reached the writing stage in your project."
  },
  {
    "objectID": "portfolio.html#project-websites",
    "href": "portfolio.html#project-websites",
    "title": "Portfolio",
    "section": "Project Websites",
    "text": "Project Websites\nOur team also helped build a website for the Soil Organic Matter (SOM) working group. One of this group’s primary products was a synthesized data package containing observed data, modifications of that data, and models based on them. The website operates in part to publicize this data product but also to provide a central location for other resources developed by or important to the SOM group.\nFor your group we can (if desired):\n\nBuild a website using Quarto\n\nAll website content creation can be done via RStudio which your group may already be somewhat familiar with\nQuarto also offers a new “visual editor” that lets you format text as you would in any word processor (i.e., Microsoft Word, Pages, etc.)\n\nMaintain the website OR help you to maintain it\n\nQuarto is written entirely in “Markdown syntax” which makes it easily maintained by either our team or yours depending on your preference\nWe have also created a tutorial on making websites with Quarto that you are welcome to explore!"
  },
  {
    "objectID": "portfolio.html#r-packages",
    "href": "portfolio.html#r-packages",
    "title": "Portfolio",
    "section": "R Packages",
    "text": "R Packages\n\n\nscicomptools\nWhile much of the work we do is specific to a given working group or task, sometimes we realize afterwards that our functions have the potential to be useful beyond the scope for which they were initially written. To that end, we have created the R package scicomptools!\n\nPackage Description\nThis package contains a diverse mix of functions for everything from repetitive data wrangling tasks to checking whether you have a token attached for GitHub. In addition, functions that we wrote that are deprecated (usually because their internal workings have been superseded by packages on CRAN) are removed from the package but retained in the GitHub repository in case they are useful to you! All functions–both live and deprecated–are summarized in the README on the GitHub repository so take a look!\n\n\nInstallation Instructions\nTo install the package in R, use the following:\n\ninstall.packages(\"scicomptools\")\n\n\n\n\n\nHERON\nWhen we’ve developed enough custom functions for a working group’s workflow, we can move those functions into its very own R package! For example, we’ve created a package for the Silica Exports working group called HERON (“HElpers for River ObservatioN”).\n\nPackage Description\nThis package contains several helper functions that are integral to the group’s workflow, which includes identifying inflection points (i.e., hills & valleys) in trendlines and running separate regressions on each chunk of the line between such points. HERON is meant to be used for workflows involving the EGRET and SiZer R packages.\n\n\nInstallation Instructions\nTo install the package in R, use the following:\n\n# install.packages(\"devtools\")\ndevtools::install_github(\"lter/HERON\")"
  },
  {
    "objectID": "portfolio.html#shiny-apps",
    "href": "portfolio.html#shiny-apps",
    "title": "Portfolio",
    "section": "Shiny Apps",
    "text": "Shiny Apps\n\nOur team created another R package–lterpalettefinder–to extract color palettes from user-supplied photos. To help non-R users still explore this package and have fun pulling color palettes from photos, we created this standalone Shiny app. This app lets anyone interact with lterpalettefinder via their browser with no R experience required!\nWe have also built apps to help working groups visualize data or present survey results in an interactive, visually-appealing format. Shiny apps can also include useful ‘overview’ portions that serve as an excellent landing page for third parties to your group’s activities!"
  },
  {
    "objectID": "tutorials.html",
    "href": "tutorials.html",
    "title": "Other Tutorials",
    "section": "",
    "text": "Some of the content that we produce is not as detailed as our full workshops but has a wider scope than the content included in our Coding Tips suggestions. This information can broadly be defined as “tutorials” though their depth and scope can vary significantly depending on the topic being tutorialized. As with our Coding Tips, this page is under constant development so please post an issue if you have an idea for a tutorial that you’d like to suggest that we create."
  },
  {
    "objectID": "tutorials.html#storing-user-specific-information",
    "href": "tutorials.html#storing-user-specific-information",
    "title": "Other Tutorials",
    "section": "Storing User-Specific Information",
    "text": "Storing User-Specific Information\nWorking groups sometimes need to handle user-specific information in their code. For example, if your group stores your data in the cloud (e.g., in Box, in Dropbox, etc.) each user will have a different “absolute file path” to the synced version of the data folder on their personal computer. Similarly, groups may find it valuable to use their email address in the code. While you could simply have each group member add their information (file path, email, etc.) and comment out all but one of them when you work in that script, there is a better option: user-specific JSON files!\nThe main advantage of this method is that you and your group members do not have to manually change any user-specific information in scripts just because a different person runs them!\n\nPrerequisites\nTo follow along with this tutorial you will need to take the following steps:\n\nDownload R\nDownload RStudio\nInstall the jsonlite R package\n\nFeel free to skip any steps that you have already completed!\n\n\n1. Create the JSON\nFirst, you’ll need to use RStudio to create your JSON file by creating a new text file (in the top left of RStudio click “File”  “New File”  “Text File”). In the new text file, add content that looks like this:\n\n{\n  \"email\":\"my_email@gmail.com\"\n  \"dropbox_path\":\"path/to/dropbox-sync/for/me\"\n}\n\nReplace the content on the right of the colon with your actual information. If desired, you can add as many other pieces of user-specific information as you’d like! Simply follow the \"info name\":\"info content\" format and make sure that each piece of information is on its own line.\nOne small note here for when you work with your group: all group members need to use exactly the same name to the left of each colon.\nYou’ll see later when we show an example of this but you can think of the information on the left of the colon as comparable with a column name. It doesn’t matter that the text in the “rows” will differ between users as long as the script has a consistent “column” in which to look for that text.\n\n\n2. Save the JSON with a Consistent Name\nThis may seem self-evident but all group members need to use the same file name for this new JSON file. We recommend user.json if you are undecided. This will let scripts that refer to the JSON use the same file name regardless of which user is running the code (same spirit as using consistent names for each piece of information in the file.)\n\n\n3. Tell Git to Ignore the JSON\nIf you’re using version control for your project (which we strongly recommend!), you’ll want Git to ignore the fact that this file differs for each user. Navigate to the .gitignore file of your project and put in the name of your JSON file as one of the files to ignore. We don’t want to push the JSON to GitHub since each person’s file will look different (that is our intent after all) and you wouldn’t want to accidentally overwrite your teammate’s user-specific information or cause a merge conflict.\nFor a deeper dive into the .gitignore check out that module of our “Collaborative Coding with GitHub” workshop!\n\n\n4. Benefit from the JSON!\nIf you’ve made it through the preceding steps, you can now use the information you stored in the JSON file. You’ll need to use the jsonlite R package to read in your file but once you’ve done that, you can access the information inside of it in classic R fashion.\nSee an example below:\n\n# Load needed library\nlibrary(jsonlite)\n\n# Read in the JSON file\nuser_info &lt;- jsonlite::read_json(\"user.json\")\n\n# Grab the file path out of it\ndropbox &lt;- user_info$dropbox_path\n\n# Use it as you would any other file path\nmy_data &lt;- read.csv(file = file.path(dropbox, \"2024_data.csv\"))\n\nNow everyone in your group can use the same script because their personal file paths are readily accessible without needing to be hard-coded! The same theory applies to any other piece of information your group finds it valuable to store in the JSON.\n\nHelp with Absolute File Paths\nIdentifying and manually writing out an absolute file path can be cumbersome so we’ve found a nice work-around (at least for Mac users) that you may find useful. First, in Finder, navigate to the last folder in the file path you’d like to preserve. In the row of folder names in the bottom of the Finder window, right-click the folder name and select “Copy ‘&lt;folder name&gt;’ as Pathname”.\nOnce you’ve done that, you can simply paste the file path into your JSON file."
  },
  {
    "objectID": "tutorials.html#using-the-googledrive-r-package",
    "href": "tutorials.html#using-the-googledrive-r-package",
    "title": "Other Tutorials",
    "section": "Using the googledrive R Package",
    "text": "Using the googledrive R Package\nThe googledrive R package is a package that lets R users directly interact with files on GoogleDrive. This can be extremely useful because it lets all members of a team share the same source data file(s) and guarantees that updates to “living” documents are received by all group members the next time they run their R script. This package is technically part of the Tidyverse but is not loaded by running library(tidyverse).\nBecause this package requires access to an R user’s GoogleDrive, you must “authenticate” the googledrive package. This essentially tells Google that it is okay if an R package uses your credentials to access and (potentially) modify your Drive content. There are only a few steps to this process but follow along with the below tutorial and we’ll get you ready to integrate the Google Drive into your code workflows using the googledrive package in no time!\n\nPrerequisites\nTo follow along with this tutorial you will need to take the following steps:\n\nDownload R\nDownload RStudio\nCreate a Gmail account\n\nFeel free to skip any steps that you have already completed!\n\n\nAuthorize googledrive\nIn order to connect R with a GoogleDrive, we’ll need to authorize googledrive to act on our behalf. This only needs to be done once (per computer) so follow along and you’ll be building GoogleDrive into your workflows in no time!\nFirst, install the googledrive and httpuv R packages. The googledrive package’s need is self-evident while the httpuv package makes the following steps a little easier than googledrive makes it alone. Be sure to load the googledrive package after you install it!\n\n# Install packages\ninstall.packages(c(\"googledrive\", \"httpuv\"))\n\n# Load them\nlibrary(googledrive)\n\nOnce you’ve installed the packages we can begin the authentication in R using the drive_auth function in the googledrive package.\n\ngoogledrive::drive_auth(email = \"enter your gmail here!\")\n\nIf this is your first time using googledrive, drive_auth will kick you to a new tab of your browser (see below for a screen grab of that screen) where you can pick which Gmail you’d like to connect to R.\n\n\n\nClick the Gmail you want to use and you will get a second screen where Google tells you that “Tidyverse API” wants access to your Google Account. This message is followed by three checkboxes, the first two are grayed out but the third is unchecked.\n\n\n\n\n\n\n\n\n\nNOTE\n\n\n\nThis next bit is vitally important so carefully read and follow the next instruction!\n\n\nIn this screen, you must check the unchecked box to be able to use the googledrive R package. If you do not check this box all attempts to use googledrive functions will get an error that says “insufficient permissions”.\n\n\n\nWhile granting access to “see, edit, create, and”delete” all of your Google Drive files” sounds like a significant security risk, those powers are actually why you’re using the googledrive package in the first place! You want to be able to download existing Drive files, change them in R on your computer, and then put them back in Google Drive which is exactly what is meant by “see, edit, create, and delete”.\nAlso, this power only applies to the computer you’re currently working on! Granting access on your work computer allows only that computer to access your Drive files. So don’t worry about giving access to your Drive to the whole world, that is protected by the same failsafes that you use when you let your computer remember a password to a website you frequent.\nAfter you’ve checked the authorization box, scroll down and click the “Continue” button.\n\n\n\nThis should result in a plain text page that tells you to close this window and return to R. If you see this message you are ready to use the googledrive package!\n\n\n\n\n\nProblems with Authorization\nIf you have tried to use drive_auth and did not check the box indicated above, you need to make the googledrive package ask you again. Using drive_auth will not (annoyingly) return you to the place it sent you the first time. However, if you run the following code chunk it should give you another chance to check the needed box.\nThe gargle R package referenced below is required for interacting with Google Application Program Interfaces (APIs). This package does the heavy lifting of secure password and token management and is necessary for the googledrive authentication chunk below.\n\ngoogledrive::drive_auth(\n  email = gargle::gargle_oauth_email(),\n  path = NULL,\n  scopes = \"https://www.googleapis.com/auth/drive\",\n  cache = gargle::gargle_oauth_cache(),\n  use_oob = gargle::gargle_oob_default(),\n  token = NULL)\n\nUnfortunately, to use the googledrive package you must check the box that empowers the package to function as designed. If you’re uncomfortable giving the googledrive that much power you will need to pivot your workflow away from using GoogleDrive directly. However, NCEAS does offer access to an internal server called “Aurora” where data can be securely saved and shared among group members without special authentication like what googledrive requires. Reach out to our team if this seems like a more attractive option for your working group and we can offer training on how to use this powerful tool!\n\n\nFind and Download Files\nNow that you’ve authorized the googledrive package, you can start downloading the Google Drive files you need through R! Let’s say that you want to download a csv file from a folder or shared drive. You can save the URL of that folder/shared drive to a variable.\nThe googledrive package makes it straightforward to access Drive folders and files with the as_id function. This function allows the full link to a file or folder to serve as a direct connection to that file/folder. Most of the other googledrive functions will require a URL that is wrapped with as_id in this way. You would replace “your url here” with the actual link but make sure it is in quotation marks.\n\ndrive_url &lt;- googledrive::as_id(\"your url here\")\n\nTo list all the contents of this folder, we can use the drive_ls function. You will get a dataframe-like object of the files back as the output. An example is shown below in the screenshot. Here, this Google Drive folder contains 4 csv files: ingredients.csv, favorite_soups.csv, favorite_fruits.csv and favorite_desserts.csv\n\ndrive_folder &lt;- googledrive::drive_ls(path = drive_url)\ndrive_folder\n\n\n\n\nIf it has been a while since you’ve used googledrive, it will prompt you to refresh your token. Simply enter the number that corresponds to the correct Google Drive account.\n\n\n\nIf you only want to list files of a certain type, you can specify this in the type argument. And let’s say that my folder contains a bunch of csv files, but I only want to download the one named “favorite_desserts.csv”. In that case, I can also put a matching string in the pattern argument in order to filter down to 1 file.\n\ndrive_folder &lt;- googledrive::drive_ls(path = drive_url,\n                                      type = \"csv\", \n                                      pattern = \"favorite_desserts\")\ndrive_folder\n\n\n\n\nOnce we’ve narrowed down to the file we want, we can download it using drive_download. This function takes the file identifier as an argument so we can access it using drive_folder$id.\n\ngoogledrive::drive_download(file = drive_folder$id)\n\nThis will automatically download the file to our working directory. If you want, you can specify a different path to download to. Just put the new file path into the path argument, replacing the “your path here”, but keep the quotation marks.\n\ngoogledrive::drive_download(file = drive_folder$id, \n                            path = \"your path here\")\n\nIf you’ve downloaded the file before, and you want to overwrite it, there’s a handy overwrite argument that you can set to TRUE. Note that the default is FALSE.\n\ngoogledrive::drive_download(file = drive_folder$id, \n                            path = \"your path here\",\n                            overwrite = T)\n\nIf there are multiple files in the Drive folder and you want to download them all, you can use a loop like so:\n\n# For each file:\nfor(focal_file in drive_folder$name){\n  \n  # Find the file identifier for that file\n  file_id &lt;- subset(drive_folder, name == focal_file)\n\n  # Download that file\n  drive_download(file = file_id$id, \n                 path = \"your path here\",\n                 overwrite = T)\n}"
  },
  {
    "objectID": "tutorials.html#building-a-website-with-quarto",
    "href": "tutorials.html#building-a-website-with-quarto",
    "title": "Other Tutorials",
    "section": "Building a Website with Quarto",
    "text": "Building a Website with Quarto\nQuarto is a new tool developed by RStudio (the company, not the program) to create a more ‘what you see is what you get’ editor for creating markdown files and products (e.g., books, websites, etc.). Additionally, it includes a visual editor that allows users to insert headings and embed figures via buttons that are intuitively labeled rather than through somewhat arcane HTML text or symbols. While Quarto is still in its infancy, it is rapidly gathering a following due to the aforementioned visual editor and for the ease with which quarto documents and websites can be created.\n\nPrerequisites\nTo follow along with this tutorial you will need to take the following steps:\n\nDo all of the pre-workshop steps relevant to our “Collaborative Coding with GitHub” workshop\nDownload Quarto\n\nFeel free to skip any steps that you have already completed!\n\n\nCreate a Quarto Website R Project\nTo begin, click the “Project” button in the top right of your RStudio session.\n\nIn the resulting dialogue, click the “New Directory” option.\n\n\n\nFrom the list of options for project templates, select “Quarto Website”.\n\n\n\nPick a title and check the “Create a git repository” checkbox. For your title, short but descriptive titles are most effective. Once that is done, click “Create Project” in the bottom right of the window.\n\n\n\nAfter a few seconds, RStudio should refresh with a Quarto document (such documents have the file extension “.qmd”) and a “_quarto.yml” file open.\n\n\n\nPart of Quarto’s central philosophy is that all of the formatting of individual .qmd files in a project is governed by the settings created by a singular .yml file. In an R markdown project some of the global settings are set in .yml but other settings are handled within each .Rmd file. This centralization is a key innovation in streamlining projects and is one reason for Quarto’s quick popularity.\n\n\nPreparing Project for Web Deployment\nTo prepare your project for web deployment via GitHub Pages, we have three quick steps that we must first complete.\nFirst, in the “_quarto.yml” file, add output-dir: docs as a subheading beneath the project: heading. Make sure that the indentation is the same as the type: website but the new line can be either above or below that line.\n\n\n\nSecond, in the “Terminal” pane run touch .nojekyll. This creates a file called “.nojekyll” that is necessary for hosting your website via GitHub Pages.\nThird, in the “Terminal” pane run quarto render. This processes the template .qmd files you currently have in the repository and prepares them to become actual web pages.\nOnce you’ve done these three things you can move on to creating a GitHub repository so that we can take the necessary steps to having GitHub host your website!\n\n\nMake a New GitHub Repository\nFrom your GitHub “Repositories” tab, click the  green  “New” button.\n\nAdd a title to your repository and add a description. Once you’ve added these two things, scroll down and click the  green  “Create repository” button.\n\n\n\nBe sure that you do not add a README, do not add a gitignore, and do not add a license. Adding any of these three will cause a merge conflict when we link the project that you just created with the GitHub repository that you are in the process of creating.\n\n\n\nAfter a few seconds you should be placed on your new repository’s landing page which will look like the below image because there isn’t anything in your repository (yet).\nCopy the link in the field and go back to your RStudio session.\n\n\n\n\n\nAdding your Project to GitHub\nThe following steps include a sequence of command line operations that will be relayed in code chunks below. Unless otherwise stated, all of the following code should be run in “Terminal”.\nIf you didn’t check the “Create a git repository” button while creating the R project, you’ll need to do that via the command line now. If you did check that box, you should skip this step!\n\n# Start a git repository on the \"main\" branch\ngit init -b main\n\nStage all of the files in your project to the git repository. This includes the .yml file, all .qmd files and all of their rendered versions created when you ran quarto render earlier. This code is equivalent to checking the box for the files in the “Git” pane of RStudio.\n\n# Stage all files\ngit add .\n\nOnce everything has been staged, you now must commit those staged files with a message.\n\n# Commit all files with the message in quotes\ngit commit -m \"Initial commit\"\n\nNow that your project files have been committed, you need to tell your computer where you will be pushing to and pulling from. Paste the link you copied at the end of the “Make a New GitHub Repository” into the code shown in the chunk below (instead of GITHUB_URL) and run it.\n\n# Tell your computer which GitHub repository to connect to\ngit remote add origin GITHUB_URL\n\nVerify that URL before continuing.\n\n# Confirm that URL worked\ngit remote -v\n\nFinally, push your commited changes to the repostory that you set as the remote in the preceding two steps.\n\n# Push all of the content to the main branch\ngit push -u origin main\n\nNow, go back to GitHub and refresh the page to see your project content safe and sound in your new GitHub repository!\n\n\n\nDeploy Website via GitHub\nIn order to get your new website actually on the web, we’ll need to tell GitHub that we want our website to be accessible at a .github.io URL.\nTo do this, go to the “Settings” tab with a gear icon and click it. You may be prompted to re-enter your GitHub password, do so and you can proceed.\n\nIn the resulting page, look towards the bottom of the left sidebar of settings categories and click the “Pages” option. This is at the very bottom of the sidebar in the screen capture below but is towards the middle of all of the settings categories Github offers you.\n\nScroll down to the middle of this page and where it says “Branch” click the dropdown menu that says “None” by default.\n\nSelect “main” from the dropdown.\n\n\n\nThis opens up a new dropdown menu where you can select which folder in your repository contains your website’s content (it defaults to “/ (root)”). Because we specified output-dir: docs in the .yml file earlier we can select “/docs” from the dropdown menu.\n\n\n\nOnce you’ve told GitHub that you want a website generated from the “docs” folder on the main branch, click the “Save” button.\n\n\n\nFrom this moment your website has begun being deployed by GitHub! You can check the status of the building process by navigating to the “Actions” tab of your repository.\nSelect the “pages build and deployment workflow” in the list of workflows on the bottom righthand side of the page.\n\nThis shows you GitHub’s building and deployment process as a flowchart. While it is working on each step there will be an amber circle next to the name of that sub-task. When a sub-task is completed, the amber circle becomes a green circle with a check mark.\n\nWhen the three steps are complete the amber clock symbol next to the “pages build and deployment” action will turn into a larger green circle with a check mark. This is GitHub’s way of telling you that your website is live and accessible to anyone on the internet.\n\nYou can now visit your website by visiting its dedicated URL. This URL can be found by returning to the “Settings” tab and then scrolling through the sidebar to the “Pages” section.\nAlternately, the website for your repository always uses the following composition: https://repository owner.github.io/repository name/\n\nIf we visit that link, we can see that our website is live!\n\n\nGitHub Housekeeping\nWe recommend a quick housekeeping step now to make it easier to find this URL in the future. Copy the URL from the Pages setting area and return to the “Code” tab of the repository.\nOnce there, click the small gear icon to the right of the “About” header.\n\nIn the resulting window, paste the copied URL into the “Website” field. Once you’ve pasted it in, click the green “Save changes” button.\n\n\n\nThis places the link to your deployed website in an intuitive, easy-to-find location both for interested third parties and yourself in the future.\n\n\n\n\nAdding Website Content\nNow that you have a live website you can build whatever you’d like! Given the wide range of possibility, we’ll only cover how to add a new page but the same process applies to any edit to the living webpage.\nTo add a new page create a new Quarto document. You can do this by going to the “File” menu, entering the “New File” options, and selecting “Quarto Document…”\n\n\n\nSimilarly to an R markdown file, this will open a new window that lets you enter a title and author as well as decide what format you want to render files to along with some other settings options. You only need to click the “Create” button in the bottom right of this dialogue (though you can definitely play with the other options and text boxes as you desire).\n\n\n\nAfter a moment, a new .qmd file will open in Quarto’s visual editor. For the purposes of this tutorial, you only need to add a title in the top of the file but for a real website you can add whatever content sparks joy for you!\n\n\n\nSave that file into your project folder. Its name can be anything but be sure that you remember what you name it!\n\n\n\nAdd the name of the new Quarto document to the .yml file in the website navbar area (in this example the file is called “more-stuff.qmd”).\n\n\n\nOnce you’ve added the file to the fundamental architecture of your website, you need to tell Quarto to re-build the part of the website that GitHub looks for when it deploys. To do this run quarto render in the Terminal.\nIf you want to preview your changes, run quarto preview in the Terminal and a new browser window will be displayed showing your current website content. This preview continues until you click the red stop sign icon in RStudio so be sure to end it when you’re done with the preview!\n\nRegardless, once you’ve run either quarto render or quarto preview you need to stage and commit all changed files indicated in the Git pane of RStudio. As a reminder, to stage files you check the box next to them, to commit staged files, type an informative message and press the “Commit” button in the right side of the window.\n\nSwitch back to GitHub and you’ll see an amber dot next to the commit hash just beneath and to the left of the green “Code” button.\n\nWhen the amber dot turns into a green check mark that means that your edits to your website are now included in the live version of your site!\n\nWhen you visit your website you may need to refresh the page for your edits to appear but all new visitors will see the updated content when they load the page.\n\n\n\nSupplementary Information\nQuarto is developing at a rapid pace so quality of life changes and new functionalities are introduced relatively frequently. Additionally, Quarto supports user-created “extensions” that can be downloaded in a given project and then used (similar to the way user-developed R packages can be shared) so if you want to do something that Quarto itself doesn’t support, chances are you’ll be able to find an extension that handles it.\nQuarto’s documentation of website creation and formatting is extremely thorough and is a great resource as you become more comfortable with your new website. We hope this tutorial was useful to you and welcome constructively critical feedback! Please post an issue with any thoughts for improvement that you have."
  },
  {
    "objectID": "modules_tutorials/quarto-website_deploy-prep.html",
    "href": "modules_tutorials/quarto-website_deploy-prep.html",
    "title": "LTER Scientific Computing Team",
    "section": "",
    "text": "To prepare your project for web deployment via GitHub Pages, we have three quick steps that we must first complete.\nFirst, in the “_quarto.yml” file, add output-dir: docs as a subheading beneath the project: heading. Make sure that the indentation is the same as the type: website but the new line can be either above or below that line.\n\n\n\nSecond, in the “Terminal” pane run touch .nojekyll. This creates a file called “.nojekyll” that is necessary for hosting your website via GitHub Pages.\nThird, in the “Terminal” pane run quarto render. This processes the template .qmd files you currently have in the repository and prepares them to become actual web pages.\nOnce you’ve done these three things you can move on to creating a GitHub repository so that we can take the necessary steps to having GitHub host your website!"
  },
  {
    "objectID": "modules_tutorials/github-connect.html",
    "href": "modules_tutorials/github-connect.html",
    "title": "LTER Scientific Computing Team",
    "section": "",
    "text": "The following steps include a sequence of command line operations that will be relayed in code chunks below. Unless otherwise stated, all of the following code should be run in “Terminal”.\nIf you didn’t check the “Create a git repository” button while creating the R project, you’ll need to do that via the command line now. If you did check that box, you should skip this step!\n\n# Start a git repository on the \"main\" branch\ngit init -b main\n\nStage all of the files in your project to the git repository. This includes the .yml file, all .qmd files and all of their rendered versions created when you ran quarto render earlier. This code is equivalent to checking the box for the files in the “Git” pane of RStudio.\n\n# Stage all files\ngit add .\n\nOnce everything has been staged, you now must commit those staged files with a message.\n\n# Commit all files with the message in quotes\ngit commit -m \"Initial commit\"\n\nNow that your project files have been committed, you need to tell your computer where you will be pushing to and pulling from. Paste the link you copied at the end of the “Make a New GitHub Repository” into the code shown in the chunk below (instead of GITHUB_URL) and run it.\n\n# Tell your computer which GitHub repository to connect to\ngit remote add origin GITHUB_URL\n\nVerify that URL before continuing.\n\n# Confirm that URL worked\ngit remote -v\n\nFinally, push your commited changes to the repostory that you set as the remote in the preceding two steps.\n\n# Push all of the content to the main branch\ngit push -u origin main\n\nNow, go back to GitHub and refresh the page to see your project content safe and sound in your new GitHub repository!"
  },
  {
    "objectID": "modules_tutorials/quarto-website_new-proj.html",
    "href": "modules_tutorials/quarto-website_new-proj.html",
    "title": "LTER Scientific Computing Team",
    "section": "",
    "text": "To begin, click the “Project” button in the top right of your RStudio session.\n\nIn the resulting dialogue, click the “New Directory” option.\n\n\n\nFrom the list of options for project templates, select “Quarto Website”.\n\n\n\nPick a title and check the “Create a git repository” checkbox. For your title, short but descriptive titles are most effective. Once that is done, click “Create Project” in the bottom right of the window.\n\n\n\nAfter a few seconds, RStudio should refresh with a Quarto document (such documents have the file extension “.qmd”) and a “_quarto.yml” file open.\n\n\n\nPart of Quarto’s central philosophy is that all of the formatting of individual .qmd files in a project is governed by the settings created by a singular .yml file. In an R markdown project some of the global settings are set in .yml but other settings are handled within each .Rmd file. This centralization is a key innovation in streamlining projects and is one reason for Quarto’s quick popularity."
  },
  {
    "objectID": "modules_tutorials/googledrive-fxns.html",
    "href": "modules_tutorials/googledrive-fxns.html",
    "title": "LTER Scientific Computing Team",
    "section": "",
    "text": "Now that you’ve authorized the googledrive package, you can start downloading the Google Drive files you need through R! Let’s say that you want to download a csv file from a folder or shared drive. You can save the URL of that folder/shared drive to a variable.\nThe googledrive package makes it straightforward to access Drive folders and files with the as_id function. This function allows the full link to a file or folder to serve as a direct connection to that file/folder. Most of the other googledrive functions will require a URL that is wrapped with as_id in this way. You would replace “your url here” with the actual link but make sure it is in quotation marks.\n\ndrive_url &lt;- googledrive::as_id(\"your url here\")\n\nTo list all the contents of this folder, we can use the drive_ls function. You will get a dataframe-like object of the files back as the output. An example is shown below in the screenshot. Here, this Google Drive folder contains 4 csv files: ingredients.csv, favorite_soups.csv, favorite_fruits.csv and favorite_desserts.csv\n\ndrive_folder &lt;- googledrive::drive_ls(path = drive_url)\ndrive_folder\n\n\n\n\nIf it has been a while since you’ve used googledrive, it will prompt you to refresh your token. Simply enter the number that corresponds to the correct Google Drive account.\n\n\n\nIf you only want to list files of a certain type, you can specify this in the type argument. And let’s say that my folder contains a bunch of csv files, but I only want to download the one named “favorite_desserts.csv”. In that case, I can also put a matching string in the pattern argument in order to filter down to 1 file.\n\ndrive_folder &lt;- googledrive::drive_ls(path = drive_url,\n                                      type = \"csv\", \n                                      pattern = \"favorite_desserts\")\ndrive_folder\n\n\n\n\nOnce we’ve narrowed down to the file we want, we can download it using drive_download. This function takes the file identifier as an argument so we can access it using drive_folder$id.\n\ngoogledrive::drive_download(file = drive_folder$id)\n\nThis will automatically download the file to our working directory. If you want, you can specify a different path to download to. Just put the new file path into the path argument, replacing the “your path here”, but keep the quotation marks.\n\ngoogledrive::drive_download(file = drive_folder$id, \n                            path = \"your path here\")\n\nIf you’ve downloaded the file before, and you want to overwrite it, there’s a handy overwrite argument that you can set to TRUE. Note that the default is FALSE.\n\ngoogledrive::drive_download(file = drive_folder$id, \n                            path = \"your path here\",\n                            overwrite = T)\n\nIf there are multiple files in the Drive folder and you want to download them all, you can use a loop like so:\n\n# For each file:\nfor(focal_file in drive_folder$name){\n  \n  # Find the file identifier for that file\n  file_id &lt;- subset(drive_folder, name == focal_file)\n\n  # Download that file\n  drive_download(file = file_id$id, \n                 path = \"your path here\",\n                 overwrite = T)\n}"
  },
  {
    "objectID": "wg-setup.html",
    "href": "wg-setup.html",
    "title": "Working Group Setup Checklist",
    "section": "",
    "text": "Note\n\n\n\nPlease note that the following checklist of working group setup steps is meant to serve as internal documentation only! Our team will be taking these steps on your behalf when you are funded so none of these steps are things you (a working member/PI) need to handle.\nFeel free to contact us if you find these instructions useful and want to apply them to non-working group contexts!\nWhen new working groups are funded, our team takes a number of setup steps to create some of the infrastructure that past groups have requested/found useful. This is mainly an attempt to help the group avoid spending their precious in-person meeting time doing relatively dry technical steps that we can easily accomplish early-on. Some of these steps also set a useful ‘tone’ in terms of facilitating groups’ adherence to reproducibility best practices."
  },
  {
    "objectID": "wg-setup.html#google-shared-drive",
    "href": "wg-setup.html#google-shared-drive",
    "title": "Working Group Setup Checklist",
    "section": "Google Shared Drive",
    "text": "Google Shared Drive\nMany groups gravitate towards using Google Drive for storing data, relevant scientific literature, and (eventually) manuscript drafts. One advantage of a true Shared Drive over simply creating a folder and sharing that is that the distributed ownership of the Shared Drive makes it very difficult to accidentally delete/lose important files.\nSome groups have experience serious heartbreak when one member’s Google identity gets closed by their institution and all files/folders created by that member vanish. A Shared Drive makes this horror story an impossibility.\n\nCreating the Shared Drive\nOur @nceas.ucsb.edu email addresses are empowered to create Shared Drives. Navigate to your Google Drive, then in the left sidebar click “Shared drives”. Once there you can click the “+ New” button to create a brand new Shared Drive.\nThe naming convention you should use is: LTER-WG_WG-NAME\nNote that for groups with longer names you will want to abbreviate so that the Shared Drive name doesn’t get ambiguously cropped in a default browser window.\n\n\nAdding Users\nOnce the Shared Drive exists, add the following people as “Content Managers”:\n\nAll members of the NCEAS Scientific Computing team\nMarty Downs (LTER Network Office Director)\nThomas Hetmank (NCEAS Programmer/Analyst)\n\nWhen you reach out to the working groups you can also make a note of their emails and add them as well though you may want to first tell them about the Shared Drive before sending them a semi-random Shared Drive invite.\n\n\nContent Creation\nWe want to use as light a touch as possible here to make sure that groups feel empowered to make their Shared Drive whatever they need it to be but there are a few things we can do.\n\nMake a “Data” folder\nAdd a data log template GoogleSheet to the Data folder\n\nIn the past we have also added a README GoogleDoc but it is unclear to what extent this is used by groups. We may want to look into whether this is useful and–if not–how we can improve it."
  },
  {
    "objectID": "wg-setup.html#github-repository",
    "href": "wg-setup.html#github-repository",
    "title": "Working Group Setup Checklist",
    "section": "GitHub Repository",
    "text": "GitHub Repository\nWe encourage all groups to engage with GitHub for–at minimum–storing their final code products. We have found that creating a GitHub repository at this stage tends to increase adoption of GitHub and is therefore very much worthwhile even if no group members use it at the time that their group gets funded.\n\nInitialize Repository\nMake a repository in the LTER GitHub Organization with the following information:\n\nCreate a name that fits one of the following naming conventions\n\nFor full working groups (3-4 meetings): “lterwg-abbreviated-group-name”\nFor SPARC groups (1 meeting): “lter-sparc-abbreviated-group-name”\n\nSet the “Description” to the title of the working group\n\nAs indicated on the LTER Network Office website\n\nAdd a README\nCreate a .gitignore using the R template\n\nR is the most common working group language and the .gitignore is easily changed in the event the group is primarily using a different language\n\n\n\n\nEdit README\nEdit the default README with the following content:\n\nMake a top level markdown heading (i.e., one #) with the title of the group\nMake a second level markdown heading (##) called “Project Summary”\n\nInclude a link to the group-specific page on the LTER Network Office website\n\nMake a second level markdown heading called “Supplementary Resources”\n\nAdd a link to the home page of the NCEAS Scientific Computing team (i.e., the home page of this website!)\n\n\nNote that you can make these edits directly from GitHub so you don’t need to worry about cloning at this stage!\n\n\nEdit .gitignore\nIf you used the R template then this is basically ready to go but we can make two small edits that are convenient for many groups (and easily undone for those groups that decide to do so).\n\nAdd .DS_Store\n\nThis file type (short for “Desktop Services Store”) is created by the Apple macOS operating system that stores visual information (e.g., icon positions, view options, etc.). In other words, it is a file that is completely irrelevant to reproducibility in a coding context and there will be one in every folder for Mac users. By ignoring it when we create the GitHub repository we can guarantee that no group members accidentally commit these useless (in this context) files and in so doing add clutter to their repository.\n\nAdd a wildcard *.Rproj\n\nThere is some debate about whether to ignore the .Rproj (see our summary of this discussion from our GitHub workshop materials) but for working groups the default position is that we should ignore it. There are two reasons to do this. First, working group members may change the name of the project on their local computer and then commit their uniquely-named .Rproj file. Taken to an extreme this means that there may be one .Rproj / user which can be confusing to some users and is not (in our opinion) very aesthetically pleasing. Second if groups commit a .Rproj and then later delete it, anyone who pulls that change will delete their cloned repository automatically (similar to a snake eating its own tail). By ignoring the .Rproj from the outset we can avoid this possisbility entirely."
  },
  {
    "objectID": "wg-setup.html#nceas-server",
    "href": "wg-setup.html#nceas-server",
    "title": "Working Group Setup Checklist",
    "section": "NCEAS’ Server",
    "text": "NCEAS’ Server\nSome groups wind up doing computationally-intense work (e.g., machine learning, spatial data wrangling, etc.). Such groups often find it useful to get set up on NCEAS’ server “Aurora” to leverage the greater computing power to do these heavy operations relatively quickly. However, because adoption/need for this is somewhat mixed we do not recommend creating a server group for every group before they request one.\nInstead, gage group interest and need and when it becomes relevant we can do the setup steps listed below. Note that we have a nice group-facing server tutorial in our GitHub workshop materials.\n\nReach out to Thomas Hetmank / Nick Outin to get a group made on the server for this working group\nMake sure that NCEAS Scientific Computing team staff are added as members\nMake a folder in the “shares” folder for this group\nGather emails from all interested working group members and get them added to the Aurora group"
  },
  {
    "objectID": "wg-setup.html#google-group",
    "href": "wg-setup.html#google-group",
    "title": "Working Group Setup Checklist",
    "section": "Google Group",
    "text": "Google Group\nThere is ongoing discussion within the larger NCEAS administration that this task may become something handled by NCEAS’ IT team so we will leave out our setup instructions at this time."
  },
  {
    "objectID": "data-acquisition.html",
    "href": "data-acquisition.html",
    "title": "Data Acquisition",
    "section": "",
    "text": "Since working groups may ask us to get and wrangle data from some popular databases, this page serves as a guide on acquiring data from said databases! Below are some common places where groups have asked us to request from. Please feel free to add more to the growing list as we collaborate with more and more groups."
  },
  {
    "objectID": "data-acquisition.html#guide",
    "href": "data-acquisition.html#guide",
    "title": "Data Acquisition",
    "section": "Guide",
    "text": "Guide\nThe TRY database offers a wide variety of plant trait data for many species. As of 2023, the database contains over 15 million trait records for over 300 thousand plant taxa.\n\n1. Account Registration\nTo get started, first create an account on TRY. After filling out the required fields, TRY will send an email to you with your password. Log in with your email and password.\n\n\n\n2. Terms and Conditions\nAfter logging in for the first time, TRY will direct you to its Intellectual Property Guidelines. Scroll down and click ‘I accept’ to proceed.\n\n\n\n\n\n\n3. Start a Data Request and Select Traits\nTRY will then redirect you to the Request Data page to begin a new request. This page can also be accessed by clicking “Data Portal” &gt; “TRY Database”. The recommendation is to request by traits/species.\nThen enter the numeric IDs of the traits you want data for. For example, plant height has the IDs 3106 (Plant height vegetative) and 3107 (Plant height generative).\nThe list of all trait IDs is here. There is also an option on the page to download a .txt file of all the traits.\n\n\n\n\n4. Select Species\nNext, you will be prompted to select the species you want data for. Each species is associated with a numeric ID, so enter the desired IDs in the field below. For example, 29 represents Abies alba and 56 represents Abies lasiocarpa.\nThe list of all plant IDs is here. Again, you also have the option to download a .txt file of all the plant species in case you wish to get the IDs programmatically.\n\n\n\n\n5. Choose Data Type: Public or Private\nThen, you must choose whether you want to request public data or public+private data. The former option will get you the data faster, while the latter option may take up to 14 days because the dataset custodians must respond to your request.\nIn our previous experience, requesting public data usually gets you the data within 24 hours.\n\n\n\n6. Describe Data Request\nOnce you have chosen which type of data you want, you will be prompted to enter the title and description of your project. These fields will be necessary if you requested for public+private data since the dataset custodians will need a reason to make their data available for your request.\n\n\n\n7. Add Coauthors\nAdd any relevant coauthors to your request before proceeding. It’s a good idea to add your fellow data analysts and/or working group PIs.\n\n\n\n\n8. Finish Request and Wait\nYour request is now complete! You will receive an email from TRY notifiying you that they have received your request. Wait for a subsequent email from them to get the actual download link to the data."
  },
  {
    "objectID": "data-acquisition.html#relevant-example",
    "href": "data-acquisition.html#relevant-example",
    "title": "Data Acquisition",
    "section": "Relevant Example",
    "text": "Relevant Example\nSee our GitHub issue #122 and the scripts in this folder for an example on how we pulled and integrated data from the TRY database."
  },
  {
    "objectID": "data-acquisition.html#guide-1",
    "href": "data-acquisition.html#guide-1",
    "title": "Data Acquisition",
    "section": "Guide",
    "text": "Guide\nNASA’s AppEEARS (Application for Extracting and Exploring Analysis Ready Samples) platform is a useful way of extracting spatial data within a user-defined bounding box or specific points. A ton of spatial data (including MODIS datasets) are available here so it makes this portal a useful ‘one-stop shop’ for groups that want more than one spatial variable.\n\n1. Account Registration / Sign In\nTo begin, visit the AppEEARS website and register for an account. After filling out the necessary personal information and confirming your email address you should be able to sign into the portal using your username and password.\n\n\n\n2. Begin an Extraction Request\nIn order to begin an extraction request, navigate to the “Extract” button in the navbar at the top of the site and click it. Select “Area” in the resulting dropdown menu of options.\n\n\n\n3. Pick Request Type\nYou can now decide whether to start your data request from scratch (“Start a new request” on the left) or if you’d like to use a previous request as a starting point (“Copy a previous request”). Note that uploading a request as a JSON is also available but I found the user interface intuitive enough that I wasn’t tempted to use this option.\nThe primary advantage–as I see it–of duplicating a request is that it allows you to re-use your manually-drawn bounding box. This makes multiple requests for different datasets exactly share the same area which makes the eventual harmonization of those data that much simpler.\nStarting a new request is the option I take only when I haven’t previously drawn a bounding box for the area of interest.\n\n\n\n4. Fill out Request\nRegardless of whether you’re starting from a blank slate or from a previous request, the next step involves customizing this request. You’ll need to perform the following steps to complete the request:\n\nEnter a name for this request\n\nThis name is only for your internal use so it can use your idiosyncrasies but should imply something about the data layer(s) and bounding box location to make it decipherable by others.\n\nDraw a polygon over your area of interest\n\nNote that the multi-point polygon tends to result in larger data requests than a square because it overlaps more separate tiles of the source data.\n\nDecide on starting/ending dates\n\nRegardless of the temporal granularity of the source data the time range requires you to specify specific days, months, and years.\n\nPick data layers for that area and time range\n\nThe search field for the data layers is pretty robust and allows you to either search MODIS codes or names of the data (e.g., “snow” or “MODIS10A2”)\n\nChoose output file format\n\nYour options are GeoTiff (i.e., raster) or netCDF\n\nChoose projection system\n\nThis option is so helpful! Specifying your projection system lets you put all of the computational labor for re-projecting into a different coordinate reference system (CRS) onto AppEEARS rather than leaving it for you to handle after the fact\n \n\n\n5. Submit Request\nWhen you are ready, click “Submit” at the bottom of the request screen \nIf your request is at or below the data limit per request, you will receive a narrow green banner at the top of the request page notifying you of the success.\n\nIf you have requested too much data you will receive a red banner notifying you of this fact and quantifying how far over the limit your request is.\n\nThe data limit is affected by (1) the spatial extent of the request, (2) the temporal extent of the request, and (3) the number of included data layers. If you are over the limit you will need to reduce one of these parameters.\nIf possible, I recommend first reducing the number of data layers as duplicating a request with a shared bounding box and time range with a different data layer is really straightforward. If you need to re-draw the bounding box you’ll need to open another data request and manually draw additional bounding boxes to eventually fill out the total area of interest which can be somewhat cumbersome.\n\n\n6. Download Completed Request\nMoments after submitting the request successfully you will receive a “Request Received” email from AppEEARS inviting you to ‘explore’ your request. This can be safely ignored as it contains only the information that you just entered.\nSome time later (usually hours if not a day or two for larger requests) you will receive a second email notifying you that the request is complete! That email has both the “Explore” link from the preceding email and a “Download” link.\nClick the provided link and on the resulting AppEEARS page you can download the data your request yields onto your computer to do with what you will.\nNote that requests do expire after a few weeks/months so you’ll want to download the data as soon as possible. If a request is expired and you’d like to re-request, there is a button to do exactly that but you’ll need to wait for the request to process again before being able to re-download the data."
  },
  {
    "objectID": "data-acquisition.html#relevant-example-1",
    "href": "data-acquisition.html#relevant-example-1",
    "title": "Data Acquisition",
    "section": "Relevant Example",
    "text": "Relevant Example\nConsult the LTER Organization-owned Silica Export GitHub repository (see the README here) for an example of how we wrangled and extracted data retrieved from AppEEARS.\nOf particular relevance is likely the “crop-drivers.R” script where we read in the data downloaded from AppEEARS and crop each data request to avoid the small amount of spatial overlap among requests. These requests ran into the data limit and had to be split among several requests that (slightly) overlap one another. To avoid re-sampling the same pixels, the rasters retrieved from AppEEARS each needed to be cropped slightly."
  },
  {
    "objectID": "data-acquisition.html#guide-2",
    "href": "data-acquisition.html#guide-2",
    "title": "Data Acquisition",
    "section": "Guide",
    "text": "Guide\nThe National Ecological Observatory Network (NEON) is a facility that collects long-term ecological data from aquatic and terrestrial ecosystems in the United States. Their data usually falls into one of three categories: data collected by an airborne observation platform like LIDAR, data collected by a person in the field, or data collected by an automated sensor.\nNEON has a handy API that will allow you to pull their data using R. Additionally, they have created a whole suite of tutorials for various needs, including a tutorial on how to download and explore NEON data using their helper R packages."
  },
  {
    "objectID": "data-acquisition.html#relevant-example-2",
    "href": "data-acquisition.html#relevant-example-2",
    "title": "Data Acquisition",
    "section": "Relevant Example",
    "text": "Relevant Example\nSee our NEON tutorial script in scicomptasks for an example on how to handle NEON data with R."
  },
  {
    "objectID": "wg_tools.html",
    "href": "wg_tools.html",
    "title": "Suggested Tools",
    "section": "",
    "text": "We primarily work on collaborative projects where we synthesize existing data to draw larger inferences than any single data set would allow. Because of this, we strongly recommend that each tool used by a team accomplish as many purposes as possible to avoid a project accruing endless “one off” tools that fit a specific purpose but do not accomplish any other tasks. Streamlining your workflow to just a few broadly useful programs also helps reduce the barrier to entry to training new team members and ensures that within team protocols are clear and concise to follow.\nThe analytical software options available at NCEAS follow directly from this ethos. Although occasionally providing specialty programs (upon request), we have otherwise carefully assembled a powerful lineup of scripted, cross-platform, scalable applications that are well-supported, generate robust results, and permit batch processing. Although these packages require an initial time investment to learn, and may seem intimidating to scientists familiar with only “point-and-click” software, we strongly argue that the long-term payoff is well worth the time investment at the start.\nWe recommend the following programs, websites, and platforms:"
  },
  {
    "objectID": "wg_tools.html#collaborative-tools",
    "href": "wg_tools.html#collaborative-tools",
    "title": "Suggested Tools",
    "section": "Collaborative Tools",
    "text": "Collaborative Tools\n\nVideo Conferencing\n\nBetween your in-person meetings at NCEAS (and during them if you have remote participants!) we recommend that you use Zoom. During the COVID-19 pandemic, Zoom became–arguably–the video chatting program and the value of your group’s familiarity with this program should not be underestimated.\n\n\nMessaging\n\nYour group will be doing a lot of written communication so we recommend creating a Slack community. The advantage of Slack over email is that you can have faster real-time conversations among multiple people without crowding your inbox. Slack also supports attaching files and “pinning” posts to make it easier to find them later. You can also create “channels” for sub-topics within your group (e.g., #paper 1, #analysis, etc.) that will allow your group members to track only the subtopics that are relevant to them. You can download the Slack desktop app here. Another team at NCEAS has created this guide for getting set up on Slack.\n\n\nDocument Sharing\n\nWe recommend that you share documents among your group using Google Drive to help you centralize your information. Our team will set up a Shared Google Drive for every working group. This drive can also be used as a staging area for your data during the data collection and exploration phases of your project. This is in part because many people are already at least somewhat familiar with Google Drive. In addition, there is an R package called googledrive that will allow you to directly connect any R scripts to Google Drive files and folders. This can be great for ensuring that all scripts use the same raw data and can be useful for exporting synthesized data products to a given Drive folder.\nFor the more analytical intensive phase of your project, NCEAS also has several analytical servers that can be used to store large data that need to be processed frequently. We’ll discuss NCEAS’ servers in greater detail further on in the onboarding process."
  },
  {
    "objectID": "wg_tools.html#computing-tools",
    "href": "wg_tools.html#computing-tools",
    "title": "Suggested Tools",
    "section": "Computing Tools",
    "text": "Computing Tools\n\nCode Storage & Versioning\n\nGit is a great program to use for tracking changes to your code as your project grows and evolves. Git is one type of “version control” software which is specifically built to track changes to code in an informative and useful way. It is analogous to using “track changes” in Microsoft Word but is built in a more seamless way and is purpose-built for working with code. You can install Git following the instructions here.\n\nSimilarly to R versus RStudio, we recommend that you create an account with GitHub so that the changes you track with Git can be viewed and interacted with in a straightforward way. GitHub is the industry standard for tracking changes to code and is a great way of making code for a specific project publicly-accessible once you are at a stage where that feels appropriate. We offer an introductory workshop on Git and GitHub that we are happy to offer to your group if that is of interest!\n\n\nAnalysis\n\nOur team is most well-versed in R and many data synthesis ends can be accomplished in this language. R’s primary advantage is its amazing user community! R users have developed all kinds of custom functions and packages so even when what you want to do is not supported by an R package on CRAN, chances are that you can find the tools you need online!\n\nWe strongly recommend using R through RStudio as the RStudio interface allows several ‘quality of life’ improvements that you will grow to greatly appreciate if you’re not already an RStudio user. RStudio enables an easier connection to Git (see below), facilitates use of the command line, and allows you to generate PDF or HTML reports with embedded code chunks for easy sharing in and outside of your group.\n\nIf your group is working with genomes or other large data files, you may find R’s memory limit to be a serious hindrance. If this is the case (or if you prefer to not use R!) we suggest Python as an alternative. Python works better with larger files and is also a well-respected programming language."
  },
  {
    "objectID": "best_practices.html",
    "href": "best_practices.html",
    "title": "Coding Tips",
    "section": "",
    "text": "This page contains the collected best practice tips of our team. More will be added over time and feel free to post an issue if you have a specific request for a section to add to this document. Please feel free to reach out to our team if you have any questions about this best practices manual and/or need help implementing some of this content.\nCheck the headings below or in the table of contents on the right of this page to see which tips and tricks we have included so far and we hope this page is a useful resource to you and your team!"
  },
  {
    "objectID": "best_practices.html#r-scripts-versus-r-markdowns",
    "href": "best_practices.html#r-scripts-versus-r-markdowns",
    "title": "Coding Tips",
    "section": "R Scripts versus R Markdowns",
    "text": "R Scripts versus R Markdowns\nWhen coding in R, either R scripts (.R files) or R markdowns (.Rmd files) are viable options but they have different advantages and disadvantages that we will cover below.\n\nR Scripts - Positives\nR scripts’ greatest strength is their flexibility. They allow you to format a file in whatever way is most intuitive to you. Additionally, R scripts can be cleaner for for loops insofar as they need not be concerned with staying within a given code chunk (as would be the case for a .Rmd). Developing a new workflow can be swiftly accomplished in an R script as some or all of the code in a script can be run by simply selecting the desired lines rather than manually running the desired chunks in a .Rmd file. Finally, R scripts can also be a better home for custom functions that can be sourced by another file (even a .Rmd!) for making repeated operations simpler to read.\n\n\nR Scripts - Potential Weaknesses\nThe benefit of extreme flexibility in R scripts can sometimes be a disadvantage however. We’ve all seen (and written) R scripts that have few or no comments or where lines of code are densely packed without spacing or blank lines to help someone new to the code understand what is being done. R scripts can certainly be written in a way that is accessible to those without prior knowledge of what the script accomplishes but they do not enforce such structure. This can make it easy, especially when we’re feeling pressed for time, to exclude structure that helps our code remain reproducible and understandable.\n\n\nR Markdowns - Positives\nR markdown files’ ability to “knit” as HTML or PDF documents makes them extremely useful in creating outward-facing reports. This is particularly the case when the specific code is less important to communicate than visualizations and/or analyses of the data but .Rmd files do facilitate echoing the code so that report readers can see how background operations were accomplished. The code chunk structure of these files can also nudge users towards including valuable comments (both between chunks and within them) though of course .Rmd files do not enforce such non-code content.\n\n\nR Markdowns - Potential Weaknesses\nR markdowns can fail to knit due to issues even when the code within the chunks works as desired. Duplicate code chunk names or a failure to install LaTeX can be a frustrating hurdle to overcome between functioning code and a knit output file. When code must be re-run repeatedly (as is often the case when developing a new workflow) the stop-and-start nature of running each code chunk separately can also be a small irritation.\n\n\nScript vs. Markdown Summary\nTaken together, both R scripts and R markdown files can empower users to write reproducible, transparent code. However, both file types have some key limitations that should be taken into consideration when choosing which to use as you set out to create a new code product."
  },
  {
    "objectID": "best_practices.html#file-paths",
    "href": "best_practices.html#file-paths",
    "title": "Coding Tips",
    "section": "File Paths",
    "text": "File Paths\nThis section contains our recommendations for handling file paths. When you code collaboratively (e.g., with GitHub), accounting for the difference between your folder structure and those of your colleagues becomes critical. Ideally your code should be completely agnostic about (1) the operating system of the computer it is running on (i.e., Windows vs. Mac) and (2) the folder structure of the computer. We can–fortunately–handle these two considerations relatively simply.\nThis may seem somewhat dry but it is worth mentioning that failing to use relative file paths is a significant hindrance to reproducibility (see Trisovic et al. 2022).\n\n1. Preserve File Paths as Objects Using file.path\nDepending on the operating system of the computer, the slashes between folder names are different (\\ versus /). The file.path function automatically detects the computer operating system and inserts the correct slash. We recommend using this function and assigning your file path to an object.\n\nmy_path &lt;- file.path(\"path\", \"to\", \"my\", \"file\")\nmy_path\n\n[1] \"path/to/my/file\"\n\n\nOnce you have that path object, you can use it everywhere you import or export information to/from the code (with another use of file.path to get the right type of slash!).\n\n# Import\nmy_raw_data &lt;- read.csv(file = file.path(my_path, \"raw_data.csv\"))\n\n# Export\nwrite.csv(x = data_object, file = file.path(my_path, \"tidy_data.csv\"))\n\n\n\n2. Create Necessary Sub-Folders in the Code with dir.create\nUsing file.path guarantees that your code will work regardless of the upstream folder structure but what about the folders that you need to export or import things to/from? For example, say your graphs.R script saves a couple of useful exploratory graphs to the “Plots” folder, how would you guarantee that everyone running graphs.R has a “Plots folder”? You can use the dir.create function to create the folder in the code (and include your path object from step 1!).\n\n# Create needed folder\ndir.create(path = file.path(my_path, \"Plots\"), showWarnings = FALSE)\n\n# Then export to that folder\nggplot2::ggsave(filename = file.path(my_path, \"Plots\", \"my_plot.png\"))\n\nThe showWarnings argument of dir.create simply warns you if the folder you’re creating already exists or not. There is no negative to “creating” a folder that already exists (nothing is overwritten!!) but the warning can be confusing so we can silence it ahead of time.\n\n\nFile Paths Summary\nWe strongly recommend following these guidelines so that your scripts work regardless of (1) the operating system, (2) folders “upstream” of the working directory, and (3) folders within the project. This will help your code by flexible and reproducible when others are attempting to re-run your scripts!\nAlso, for more information on how to read files in cloud storage locations such as Google Drive, Box, Dropbox, etc., please refer to our Other Tutorials."
  },
  {
    "objectID": "best_practices.html#good-naming-conventions",
    "href": "best_practices.html#good-naming-conventions",
    "title": "Coding Tips",
    "section": "Good Naming Conventions",
    "text": "Good Naming Conventions\nWhen you first start working on a project with your group members, figuring out what to name your folders/files may not be at the top of your priority list. However, following a good naming convention will allow team members to quickly locate files and figure out what they contain. The organized naming structure will also allow new members of the group to be onboarded more easily!\nHere is a summary of some naming tips that we recommend. These were taken from the Reproducibility Best Practices module in the LTER’s SSECR course. Please feel free to refer to the aforementioned link for more information.\n\nNames should be informative\n\nAn ideal file name should give some information about the file’s contents, purpose, and relation to other project files.\nFor example, if you have a bunch of scripts that need to be run in order, consider adding step numbers to the start of each file name (e.g., “01_harmonize_data.R” or “step01_harmonize_data.R”).\n\nNames should avoid spaces and special characters\n\nSpaces and special characters (e.g., é, ü, etc.) in folder/file names may cause errors when someone with a Windows computer tries to read those file paths. You can replace spaces with delimiters like underscores or hyphens to increase machine readability.\n\nFollow a consistent naming convention throughout!\n\nIf you and your group members find a naming convention that works, stick with it! Having a consistent naming convention is key to getting new collaborators to follow it."
  },
  {
    "objectID": "best_practices.html#package-loading",
    "href": "best_practices.html#package-loading",
    "title": "Coding Tips",
    "section": "Package Loading",
    "text": "Package Loading\nLoading packages / libraries in R can be cumbersome when working collaboratively because there is no guarantee that you all have the same packages installed. While you could comment-out an install.packages() line for every package you need for a given script, we recommend using the R package librarian to greatly simplify this process!\nlibrarian::shelf() accepts the names of all of the packages–either CRAN or GitHub–installs those that are missing in that particular R session and then attaches all of them. See below for an example:\nTo load packages typically you’d have something like the following in your script:\n\n## Install packages (if needed)\n# install.packages(\"tidyverse\")\n# install.packages(\"devtools\")\n# devtools::install_github(\"NCEAS/scicomptools\")\n\n# Load libraries\nlibrary(tidyverse); library(scicomptools)\n\nWith librarian::shelf() however this becomes much cleaner! In addition to being fewer lines, using librarian also removes the possibility that someone running your code misses one of the packages that your script depends on and then the script breaks for them later on. librarian::shelf() automatically detects whether a package is installed, installs it if necessary, and then attaches the package.\nIn essence, librarian::shelf() wraps install.packages(), devtools::install_github(), and library() into a single, human-readable function.\n\n# Install and load packages!\nlibrarian::shelf(tidyverse, NCEAS/scicomptools)\n\nWhen using librarian::shelf(), package names do not need to be quoted and GitHub packages can be installed without the additional steps of installing the devtools package and using devtools::install_github() instead of install.packages()."
  },
  {
    "objectID": "pages_deprecated/wg_sci-comp-def.html",
    "href": "pages_deprecated/wg_sci-comp-def.html",
    "title": "What is Scientific Computing?",
    "section": "",
    "text": "In the most fundamental sense, scientific computing refers to the process of organizing, managing, and analyzing scientific data using computers. This process takes place at the interface between several distinct disciplines:\n\nInformatics provides both a planning framework and operational rules for acquiring, handling, interpreting, and storing the underlying information in a useful and efficient manner\nComputer science and the technologies it produces provide the overarching computational environment, including the core processing “engine” and a means to control it\nRelevant branches of mathematics, statistics, and probability arm us with numerical models, algorithms, error representations, and other constructs for describing and solving problems quantitatively\nLast but not least, the target science itself (e.g., ecology, geosciences, evolutionary biology, etc.) provides an overall motivation, research paradigm, and conceptual model to guide the analysis\n\nWith these many links to other fields, modern scientific computing is now viewed as a field of study unto itself, constantly evolving in step with advances in the disciplines on which it is based."
  },
  {
    "objectID": "modules_best-practices/pkg-loading.html",
    "href": "modules_best-practices/pkg-loading.html",
    "title": "LTER Scientific Computing Team",
    "section": "",
    "text": "Loading packages / libraries in R can be cumbersome when working collaboratively because there is no guarantee that you all have the same packages installed. While you could comment-out an install.packages() line for every package you need for a given script, we recommend using the R package librarian to greatly simplify this process!\nlibrarian::shelf() accepts the names of all of the packages–either CRAN or GitHub–installs those that are missing in that particular R session and then attaches all of them. See below for an example:\nTo load packages typically you’d have something like the following in your script:\n\n## Install packages (if needed)\n# install.packages(\"tidyverse\")\n# install.packages(\"devtools\")\n# devtools::install_github(\"NCEAS/scicomptools\")\n\n# Load libraries\nlibrary(tidyverse); library(scicomptools)\n\nWith librarian::shelf() however this becomes much cleaner! In addition to being fewer lines, using librarian also removes the possibility that someone running your code misses one of the packages that your script depends on and then the script breaks for them later on. librarian::shelf() automatically detects whether a package is installed, installs it if necessary, and then attaches the package.\nIn essence, librarian::shelf() wraps install.packages(), devtools::install_github(), and library() into a single, human-readable function.\n\n# Install and load packages!\nlibrarian::shelf(tidyverse, NCEAS/scicomptools)\n\nWhen using librarian::shelf(), package names do not need to be quoted and GitHub packages can be installed without the additional steps of installing the devtools package and using devtools::install_github() instead of install.packages()."
  },
  {
    "objectID": "modules_best-practices/markdown-vs-script.html",
    "href": "modules_best-practices/markdown-vs-script.html",
    "title": "LTER Scientific Computing Team",
    "section": "",
    "text": "When coding in R, either R scripts (.R files) or R markdowns (.Rmd files) are viable options but they have different advantages and disadvantages that we will cover below.\n\nR Scripts - Positives\nR scripts’ greatest strength is their flexibility. They allow you to format a file in whatever way is most intuitive to you. Additionally, R scripts can be cleaner for for loops insofar as they need not be concerned with staying within a given code chunk (as would be the case for a .Rmd). Developing a new workflow can be swiftly accomplished in an R script as some or all of the code in a script can be run by simply selecting the desired lines rather than manually running the desired chunks in a .Rmd file. Finally, R scripts can also be a better home for custom functions that can be sourced by another file (even a .Rmd!) for making repeated operations simpler to read.\n\n\nR Scripts - Potential Weaknesses\nThe benefit of extreme flexibility in R scripts can sometimes be a disadvantage however. We’ve all seen (and written) R scripts that have few or no comments or where lines of code are densely packed without spacing or blank lines to help someone new to the code understand what is being done. R scripts can certainly be written in a way that is accessible to those without prior knowledge of what the script accomplishes but they do not enforce such structure. This can make it easy, especially when we’re feeling pressed for time, to exclude structure that helps our code remain reproducible and understandable.\n\n\nR Markdowns - Positives\nR markdown files’ ability to “knit” as HTML or PDF documents makes them extremely useful in creating outward-facing reports. This is particularly the case when the specific code is less important to communicate than visualizations and/or analyses of the data but .Rmd files do facilitate echoing the code so that report readers can see how background operations were accomplished. The code chunk structure of these files can also nudge users towards including valuable comments (both between chunks and within them) though of course .Rmd files do not enforce such non-code content.\n\n\nR Markdowns - Potential Weaknesses\nR markdowns can fail to knit due to issues even when the code within the chunks works as desired. Duplicate code chunk names or a failure to install LaTeX can be a frustrating hurdle to overcome between functioning code and a knit output file. When code must be re-run repeatedly (as is often the case when developing a new workflow) the stop-and-start nature of running each code chunk separately can also be a small irritation.\n\n\nScript vs. Markdown Summary\nTaken together, both R scripts and R markdown files can empower users to write reproducible, transparent code. However, both file types have some key limitations that should be taken into consideration when choosing which to use as you set out to create a new code product."
  },
  {
    "objectID": "modules_best-practices/file-paths.html",
    "href": "modules_best-practices/file-paths.html",
    "title": "LTER Scientific Computing Team",
    "section": "",
    "text": "This section contains our recommendations for handling file paths. When you code collaboratively (e.g., with GitHub), accounting for the difference between your folder structure and those of your colleagues becomes critical. Ideally your code should be completely agnostic about (1) the operating system of the computer it is running on (i.e., Windows vs. Mac) and (2) the folder structure of the computer. We can–fortunately–handle these two considerations relatively simply.\nThis may seem somewhat dry but it is worth mentioning that failing to use relative file paths is a significant hindrance to reproducibility (see Trisovic et al. 2022).\n\n1. Preserve File Paths as Objects Using file.path\nDepending on the operating system of the computer, the slashes between folder names are different (\\ versus /). The file.path function automatically detects the computer operating system and inserts the correct slash. We recommend using this function and assigning your file path to an object.\n\nmy_path &lt;- file.path(\"path\", \"to\", \"my\", \"file\")\nmy_path\n\n[1] \"path/to/my/file\"\n\n\nOnce you have that path object, you can use it everywhere you import or export information to/from the code (with another use of file.path to get the right type of slash!).\n\n# Import\nmy_raw_data &lt;- read.csv(file = file.path(my_path, \"raw_data.csv\"))\n\n# Export\nwrite.csv(x = data_object, file = file.path(my_path, \"tidy_data.csv\"))\n\n\n\n2. Create Necessary Sub-Folders in the Code with dir.create\nUsing file.path guarantees that your code will work regardless of the upstream folder structure but what about the folders that you need to export or import things to/from? For example, say your graphs.R script saves a couple of useful exploratory graphs to the “Plots” folder, how would you guarantee that everyone running graphs.R has a “Plots folder”? You can use the dir.create function to create the folder in the code (and include your path object from step 1!).\n\n# Create needed folder\ndir.create(path = file.path(my_path, \"Plots\"), showWarnings = FALSE)\n\n# Then export to that folder\nggplot2::ggsave(filename = file.path(my_path, \"Plots\", \"my_plot.png\"))\n\nThe showWarnings argument of dir.create simply warns you if the folder you’re creating already exists or not. There is no negative to “creating” a folder that already exists (nothing is overwritten!!) but the warning can be confusing so we can silence it ahead of time.\n\n\nFile Paths Summary\nWe strongly recommend following these guidelines so that your scripts work regardless of (1) the operating system, (2) folders “upstream” of the working directory, and (3) folders within the project. This will help your code by flexible and reproducible when others are attempting to re-run your scripts!\nAlso, for more information on how to read files in cloud storage locations such as Google Drive, Box, Dropbox, etc., please refer to our Other Tutorials."
  },
  {
    "objectID": "modules_best-practices/naming-conventions.html",
    "href": "modules_best-practices/naming-conventions.html",
    "title": "LTER Scientific Computing Team",
    "section": "",
    "text": "When you first start working on a project with your group members, figuring out what to name your folders/files may not be at the top of your priority list. However, following a good naming convention will allow team members to quickly locate files and figure out what they contain. The organized naming structure will also allow new members of the group to be onboarded more easily!\nHere is a summary of some naming tips that we recommend. These were taken from the Reproducibility Best Practices module in the LTER’s SSECR course. Please feel free to refer to the aforementioned link for more information.\n\nNames should be informative\n\nAn ideal file name should give some information about the file’s contents, purpose, and relation to other project files.\nFor example, if you have a bunch of scripts that need to be run in order, consider adding step numbers to the start of each file name (e.g., “01_harmonize_data.R” or “step01_harmonize_data.R”).\n\nNames should avoid spaces and special characters\n\nSpaces and special characters (e.g., é, ü, etc.) in folder/file names may cause errors when someone with a Windows computer tries to read those file paths. You can replace spaces with delimiters like underscores or hyphens to increase machine readability.\n\nFollow a consistent naming convention throughout!\n\nIf you and your group members find a naming convention that works, stick with it! Having a consistent naming convention is key to getting new collaborators to follow it."
  },
  {
    "objectID": "pages_deprecated/wg_infrastructure.html",
    "href": "pages_deprecated/wg_infrastructure.html",
    "title": "Computing Infrastructure",
    "section": "",
    "text": "NCEAS offers an array of helpful computing infrastructure for your group. These resources are purely optional but can be a significant aid to your projects’ progression both when you’re in-person in Santa Barbara and between those meetings! Our team is ready and willing to explain these in greater detail or help your group build them into your workflow so don’t hesitate to reach out!"
  },
  {
    "objectID": "pages_deprecated/wg_infrastructure.html#analytical-servers",
    "href": "pages_deprecated/wg_infrastructure.html#analytical-servers",
    "title": "Computing Infrastructure",
    "section": "Analytical Servers",
    "text": "Analytical Servers\nWorking groups have access to several high-performance computers at NCEAS, which provide advanced analytical, web, and database capabilities that far exceed the capabilities of desktop computers. We are available to set up and instruct you in the use of these Linux/Unix systems for demanding scientific analyses and modeling runs that benefit from lots of memory or storage, or access to multiple CPU’s.\n\nOur most powerful system (pictured) currently offers 384GB of RAM memory, along with 44 cores (CPUs), and several terabytes of fast storage. Several scientific software packages – such as R/RStudio, Python, Matlab, and QGIS – are already installed. Ask us if you need us to install any specific analytical libraries or packages.\nWe can also set up shared storage space on our server to facilitate data sharing within your working group. This is particularly valuable for large files that would take up a significant amount of your group’s cloud storage system (e.g., Google Drive, Dropbox, etc.)\nTo request access to the NCEAS analytical server, please coordinate with your PIs and contact us with your request."
  },
  {
    "objectID": "pages_deprecated/wg_infrastructure.html#data-preservation",
    "href": "pages_deprecated/wg_infrastructure.html#data-preservation",
    "title": "Computing Infrastructure",
    "section": "Data Preservation",
    "text": "Data Preservation\nWhile we know that you are just getting started, it is never too early to start thinking about where you are going to store the data your group will collate and synthesize! NCEAS is committed to practicing and promoting open science, making scientific research and its supporting data and information accessible to all levels of society. Therefore, we recommend that any input data used for your synthesis work be well documented and preserved in a long-term data repository.\n\nIt is required to document and preserve any products resulting from working group activities in a long-term data repository, such as the Environmental Data Initiative (EDI) data repository or the NCEAS-supported KNB Data Repository, which are part of the Data Observation Network for Earth (DataONE).\n\nWe are happy to discuss which of these options might fit your group best though we recognize this discussion can probably be left alone until your group has amassed a substantial amount of data."
  },
  {
    "objectID": "team-onboarding.html",
    "href": "team-onboarding.html",
    "title": "Sci Comp Team Onboarding",
    "section": "",
    "text": "This page contains a quick, cookbook-style set of instructions for new staff on the Scientific Computing Support Team. We are so excited to have you join us and we hope that these instructions are clear and easy-to-follow. Please don’t hesitate to reach out if you run into any issues (see the “Our Team” tab of this site) or post a GitHub issue yourself on this website’s repository!\nListed below are a mix of references and tutorials on concepts we aim to promote to researchers who we support, as well as tools and workflows we use in our team. The goal is to give context about open and reproducible science principles NCEAS is promoting to the scientific community. You will also find information on getting access to the tools that you will need and some general information about working at NCEAS."
  },
  {
    "objectID": "team-onboarding.html#background-reading-material",
    "href": "team-onboarding.html#background-reading-material",
    "title": "Sci Comp Team Onboarding",
    "section": "Background Reading Material",
    "text": "Background Reading Material\n\nHampton et al 2015. “The Tao of open science for ecology”\nBorer et al 2009. “Effective Data Management”\nFegraus et al 2005. “Maximizing the Value of Ecological Data with Structured Metadata:”\nHeidborn 2008. “Shedding Light on the Dark Data in the Long Tail of Science”"
  },
  {
    "objectID": "team-onboarding.html#programs-resources",
    "href": "team-onboarding.html#programs-resources",
    "title": "Sci Comp Team Onboarding",
    "section": "Programs & Resources",
    "text": "Programs & Resources\n\nGitHub Tutorial\nWe rely heavily on GitHub for collaboration, and there are a few things you must do to get set up. First, complete the NCEAS GitHub Tutorial here. This tutorial will help you with getting started with git and GitHub using RStudio.\n\n\nLTER GitHub Organization\nRegister (if you have not already) for a personal GitHub account and send your username to Marty to be added to the LTER GitHub. This GitHub Organization “owns” the working groups repositories that you will be directly working with so being added to this organization will give you access to needed repositories.\n\n\nNCEAS GitHub Enterprise Organization\nWe use a GitHub Enterprise account to keep track of tasks for the Scientific Computing Support of LTER working groups. To be added to the account you must create an NCEAS account.\nFollow the directions outlined here and send your username to Marty Downs (not the email outlined in the Google Doc).\nAfter you have been added, you will be able to access the Issues tab of the lter-wg-scicomp GitHub repository. We use issues on this repository to keep track of tasks and projects as well as who is primarily responsible for a given task and which working group gave us the task initially.\n\n\nSlack\nWe use Slack to communicate with one another throughout the day. To be added to the NCEAS Slack group, register here. If you already have a slack account, be sure to use the email address you used to register.\nFind and join our #scicomp channel by clicking the plus sign next to the Channels section. Feel free to join any other channels that you might find interesting! Popular channels include #diversity, #nceas, and #social.\nFinally, complete this short tutorial on using Slack.\n\n\nNCEAS Server: Aurora\nWe use the Aurora server (located at aurora.nceas.ucsb.edu) when working with RStudio or JupyterHub. Send an email to help@nceas.ucsb.edu requesting an account mentioning you are working with Marty. Thomas Hetmank or Nick Outin will contact you with directions for setting up an account."
  },
  {
    "objectID": "team-onboarding.html#recurring-nceas-meetings",
    "href": "team-onboarding.html#recurring-nceas-meetings",
    "title": "Sci Comp Team Onboarding",
    "section": "Recurring NCEAS Meetings",
    "text": "Recurring NCEAS Meetings\nThere are a number of recurring meetings that you are encouraged to attend. At your hiring, you should receive an invitation to the NCEAS Google Calendar which has links to all the meeting information. These include Coffee Klatch (a coffee social), Hacky Hours, and Data Science Chats (to name a few).\nWe also have a team Google Calendar to manage team events. Marty will add you if you have not been already."
  },
  {
    "objectID": "team-onboarding.html#data-science-background-and-tutorials",
    "href": "team-onboarding.html#data-science-background-and-tutorials",
    "title": "Sci Comp Team Onboarding",
    "section": "Data Science Background and Tutorials",
    "text": "Data Science Background and Tutorials\nFor good background information on the tools that we use, read through and practice examples of the following chapters from a training we did for postdocs in early 2020: https://science-for-nature-and-people.github.io/2020-data-collab-workshop/2020-02-snapp/index.html\nChapters 3, 5, 8 are a good background about the tools we use.\nChapters 9, 10 are a good introduction to data modeling.\n\nR Self-Assessment\nFinally, please complete this R Training Assessment to self-assess your skills in R.\nSchedule a session with the rest of the team to debrief on your experience."
  },
  {
    "objectID": "team-onboarding.html#hr-related-resources",
    "href": "team-onboarding.html#hr-related-resources",
    "title": "Sci Comp Team Onboarding",
    "section": "HR-related Resources",
    "text": "HR-related Resources\n\nReporting Hours & Kronos\nWe submit vacation and sick day hours online through Kronos. You should receive an email at the start of your employment adding you to an email listserv that will send reminders on when to approve each month’s timesheet.\n\n\nUC Path\nUC Path is the online HR portal and can be accessed with your UCSB Net ID. It is where you can access things like your paycheck, next date of paycheck, and benefits (if applicable)."
  },
  {
    "objectID": "tutorial-scaffold_googledrive-auth.html",
    "href": "tutorial-scaffold_googledrive-auth.html",
    "title": "LTER Scientific Computing Team",
    "section": "",
    "text": "The googledrive R package is a package that lets R users directly interact with files on GoogleDrive. This can be extremely useful because it lets all members of a team share the same source data file(s) and guarantees that updates to “living” documents are received by all group members the next time they run their R script. This package is technically part of the Tidyverse but is not loaded by running library(tidyverse).\nBecause this package requires access to an R user’s GoogleDrive, you must “authenticate” the googledrive package. This essentially tells Google that it is okay if an R package uses your credentials to access and (potentially) modify your Drive content. There are only a few steps to this process but follow along with the below tutorial and we’ll get you ready to integrate the Google Drive into your code workflows using the googledrive package in no time!\n\nPrerequisites\nTo follow along with this tutorial you will need to take the following steps:\n\nDownload R\nDownload RStudio\nCreate a Gmail account\n\nFeel free to skip any steps that you have already completed!\n\n\nAuthorize googledrive\nIn order to connect R with a GoogleDrive, we’ll need to authorize googledrive to act on our behalf. This only needs to be done once (per computer) so follow along and you’ll be building GoogleDrive into your workflows in no time!\nFirst, install the googledrive and httpuv R packages. The googledrive package’s need is self-evident while the httpuv package makes the following steps a little easier than googledrive makes it alone. Be sure to load the googledrive package after you install it!\n\n# Install packages\ninstall.packages(c(\"googledrive\", \"httpuv\"))\n\n# Load them\nlibrary(googledrive)\n\nOnce you’ve installed the packages we can begin the authentication in R using the drive_auth function in the googledrive package.\n\ngoogledrive::drive_auth(email = \"enter your gmail here!\")\n\nIf this is your first time using googledrive, drive_auth will kick you to a new tab of your browser (see below for a screen grab of that screen) where you can pick which Gmail you’d like to connect to R.\n\n\n\nClick the Gmail you want to use and you will get a second screen where Google tells you that “Tidyverse API” wants access to your Google Account. This message is followed by three checkboxes, the first two are grayed out but the third is unchecked.\n\n\n\n\n\n\n\n\n\nNOTE\n\n\n\nThis next bit is vitally important so carefully read and follow the next instruction!\n\n\nIn this screen, you must check the unchecked box to be able to use the googledrive R package. If you do not check this box all attempts to use googledrive functions will get an error that says “insufficient permissions”.\n\n\n\nWhile granting access to “see, edit, create, and”delete” all of your Google Drive files” sounds like a significant security risk, those powers are actually why you’re using the googledrive package in the first place! You want to be able to download existing Drive files, change them in R on your computer, and then put them back in Google Drive which is exactly what is meant by “see, edit, create, and delete”.\nAlso, this power only applies to the computer you’re currently working on! Granting access on your work computer allows only that computer to access your Drive files. So don’t worry about giving access to your Drive to the whole world, that is protected by the same failsafes that you use when you let your computer remember a password to a website you frequent.\nAfter you’ve checked the authorization box, scroll down and click the “Continue” button.\n\n\n\nThis should result in a plain text page that tells you to close this window and return to R. If you see this message you are ready to use the googledrive package!\n\n\n\n\n\nProblems with Authorization\nIf you have tried to use drive_auth and did not check the box indicated above, you need to make the googledrive package ask you again. Using drive_auth will not (annoyingly) return you to the place it sent you the first time. However, if you run the following code chunk it should give you another chance to check the needed box.\nThe gargle R package referenced below is required for interacting with Google Application Program Interfaces (APIs). This package does the heavy lifting of secure password and token management and is necessary for the googledrive authentication chunk below.\n\ngoogledrive::drive_auth(\n  email = gargle::gargle_oauth_email(),\n  path = NULL,\n  scopes = \"https://www.googleapis.com/auth/drive\",\n  cache = gargle::gargle_oauth_cache(),\n  use_oob = gargle::gargle_oob_default(),\n  token = NULL)\n\nUnfortunately, to use the googledrive package you must check the box that empowers the package to function as designed. If you’re uncomfortable giving the googledrive that much power you will need to pivot your workflow away from using GoogleDrive directly. However, NCEAS does offer access to an internal server called “Aurora” where data can be securely saved and shared among group members without special authentication like what googledrive requires. Reach out to our team if this seems like a more attractive option for your working group and we can offer training on how to use this powerful tool!\n\n\nFind and Download Files\nNow that you’ve authorized the googledrive package, you can start downloading the Google Drive files you need through R! Let’s say that you want to download a csv file from a folder or shared drive. You can save the URL of that folder/shared drive to a variable.\nThe googledrive package makes it straightforward to access Drive folders and files with the as_id function. This function allows the full link to a file or folder to serve as a direct connection to that file/folder. Most of the other googledrive functions will require a URL that is wrapped with as_id in this way. You would replace “your url here” with the actual link but make sure it is in quotation marks.\n\ndrive_url &lt;- googledrive::as_id(\"your url here\")\n\nTo list all the contents of this folder, we can use the drive_ls function. You will get a dataframe-like object of the files back as the output. An example is shown below in the screenshot. Here, this Google Drive folder contains 4 csv files: ingredients.csv, favorite_soups.csv, favorite_fruits.csv and favorite_desserts.csv\n\ndrive_folder &lt;- googledrive::drive_ls(path = drive_url)\ndrive_folder\n\n\n\n\nIf it has been a while since you’ve used googledrive, it will prompt you to refresh your token. Simply enter the number that corresponds to the correct Google Drive account.\n\n\n\nIf you only want to list files of a certain type, you can specify this in the type argument. And let’s say that my folder contains a bunch of csv files, but I only want to download the one named “favorite_desserts.csv”. In that case, I can also put a matching string in the pattern argument in order to filter down to 1 file.\n\ndrive_folder &lt;- googledrive::drive_ls(path = drive_url,\n                                      type = \"csv\", \n                                      pattern = \"favorite_desserts\")\ndrive_folder\n\n\n\n\nOnce we’ve narrowed down to the file we want, we can download it using drive_download. This function takes the file identifier as an argument so we can access it using drive_folder$id.\n\ngoogledrive::drive_download(file = drive_folder$id)\n\nThis will automatically download the file to our working directory. If you want, you can specify a different path to download to. Just put the new file path into the path argument, replacing the “your path here”, but keep the quotation marks.\n\ngoogledrive::drive_download(file = drive_folder$id, \n                            path = \"your path here\")\n\nIf you’ve downloaded the file before, and you want to overwrite it, there’s a handy overwrite argument that you can set to TRUE. Note that the default is FALSE.\n\ngoogledrive::drive_download(file = drive_folder$id, \n                            path = \"your path here\",\n                            overwrite = T)\n\nIf there are multiple files in the Drive folder and you want to download them all, you can use a loop like so:\n\n# For each file:\nfor(focal_file in drive_folder$name){\n  \n  # Find the file identifier for that file\n  file_id &lt;- subset(drive_folder, name == focal_file)\n\n  # Download that file\n  drive_download(file = file_id$id, \n                 path = \"your path here\",\n                 overwrite = T)\n}"
  },
  {
    "objectID": "wg_services.html",
    "href": "wg_services.html",
    "title": "Working Together",
    "section": "",
    "text": "We are excited to work with your team to help you develop reproducible workflows to process, harmonize, and analyze the large amount of (heterogeneous) data necessary to conduct synthesis science. Those reproducible workflows will help you to integrate new information more easily, iterate more quickly to test your various hypotheses, and enable you to better collaborate. We currently offer a range of options for what our collaboration might look like.\nThe categories below are not exhaustive so if you think your needs will fall between or outside of these tasks, please don’t hesitate to contact our team to start that conversation!"
  },
  {
    "objectID": "wg_services.html#tasks",
    "href": "wg_services.html#tasks",
    "title": "Working Together",
    "section": "Tasks",
    "text": "Tasks\nThis level of collaboration is the core of our value to working groups! When your group identifies a data-related need (e.g., designing an analytical workflow, creating a website, writing an R Shiny app, etc.), you reach out to our team and get the conversation started. During that time we will work closely with you to define the scope of the work and get a clear picture of what “success” looks like in this context.\nOnce the task is appropriately defined, the conversation moves on to how independently you’d like us to work. This varies dramatically between tasks even within a single working group and there is no single right answer! For some tasks, we are capable of working completely independently and returning to your team with a finished product in hand for review but we are equally comfortable working closely with you throughout the life-cycle of a task."
  },
  {
    "objectID": "wg_services.html#analytical-sprints",
    "href": "wg_services.html#analytical-sprints",
    "title": "Working Together",
    "section": "Analytical Sprints",
    "text": "Analytical Sprints\nFor more intense support, we offer “analytical sprints.” If your group requests an analytical sprint, you will get one of our team members working full time only for your group’s tasks for 3-4 weeks! This can be a great option if your group has many smaller tasks or fewer larger projects that are particularly time-sensitive.\nWe are excited that these sprints are a part of our menu of offerings to you all but please reach out to us to start the conversation before requesting a sprint so that we can make sure we are all on the same page."
  },
  {
    "objectID": "wg_services.html#weekly-office-hours",
    "href": "wg_services.html#weekly-office-hours",
    "title": "Working Together",
    "section": "Weekly Office Hours",
    "text": "Weekly Office Hours\nEach of our staff members offers a one-hour block weekly as a standing office hour each week. This is a great time to join us with small hurdles or obstacles you’re experiencing in a given week. For example, previous office hours have dealt with topics like refreshing on Git/GitHub vocabulary, authenticating the googledrive R package, or solving a specific error in a new R script."
  },
  {
    "objectID": "wg_services.html#workshops-trainings",
    "href": "wg_services.html#workshops-trainings",
    "title": "Working Together",
    "section": "Workshops & Trainings",
    "text": "Workshops & Trainings\nWith those workshops, our team aims to help your group further develop skills in reproducible data science to enable your team to better collaborate and efficiently tackle data and analytical challenges. It is sometimes the case that your working group wants to become more familiar (or get a refresher) on a tool you’d like to include in your group’s workflow. To that end we can offer workshops on a selection of data science tools.\nFor our current workshop catalog, see here.\nWe are also happy to offer new workshops if your group wants training on something within our knowledge base for which we haven’t (yet) built a workshop. These workshops are typically done remotely (we can also accommodate time during one of your meetings if desired) and last 2-3 hours but we can be flexible with that timing depending on your group’s needs.\nSimilarly, we also have been creating more ‘go at your own pace’-style tutorials that can be accessed here. These tutorials are usually smaller in scope than workshops but are still built to maximize value to your group either as review or first contact with a given subject. As with the workshops, we are happy to create new tutorials if something comes up for your team so please reach out and we can discuss further!"
  },
  {
    "objectID": "wg_facilitation.html",
    "href": "wg_facilitation.html",
    "title": "Meeting Facilitation & Santa Barbara Tips",
    "section": "",
    "text": "Facilitating a working group meeting is both hugely rewarding and a significant effort. NCEAS and the LTER Network have gathered some guiding resources that may prove to be helpful to your meeting. See the sub-sections below for more details."
  },
  {
    "objectID": "wg_facilitation.html#lter-network-office-guidance",
    "href": "wg_facilitation.html#lter-network-office-guidance",
    "title": "Meeting Facilitation & Santa Barbara Tips",
    "section": "LTER Network Office Guidance",
    "text": "LTER Network Office Guidance\nThe LTER Network Office (LNO) has curated some useful resources on their website (lternet.edu) that we strongly recommend exploring! In particular, the LNO has centralized resources for working group primary investigators (PIs) (see here). Additionally, the LNO has created some broader resources for all members of working groups (see here).\nThe LTER Code of Conduct is also publicly available if you’d like to explore it."
  },
  {
    "objectID": "wg_facilitation.html#nceas-resources-for-working-groups",
    "href": "wg_facilitation.html#nceas-resources-for-working-groups",
    "title": "Meeting Facilitation & Santa Barbara Tips",
    "section": "NCEAS’ Resources for Working Groups",
    "text": "NCEAS’ Resources for Working Groups\nNCEAS hosts many working groups and so has drawn from its wealth of experience to assemble a set of useful information on its Resources for Working Groups page.\nIn particular, we recommend checking out the documents nested in the “How to Run a Working Group” dropdown menu. Your group may also want to check out the “Reimbursement Forms” dropdown after your meetings in Santa Barbara to ensure that your eligible expenses get reimbursed!"
  },
  {
    "objectID": "wg_facilitation.html#diversity-equity-and-inclusion",
    "href": "wg_facilitation.html#diversity-equity-and-inclusion",
    "title": "Meeting Facilitation & Santa Barbara Tips",
    "section": "Diversity, Equity, and Inclusion",
    "text": "Diversity, Equity, and Inclusion\nThe LTER Network and NCEAS are committed to improving diversity and inclusion in science. For the LTER Network Office’s diversity, equity and inclusion resources see here. For more information on NCEAS’ commitment to this mission–and related links–please visit NCEAS’ DEIJ page."
  },
  {
    "objectID": "wg_facilitation.html#visiting-santa-barbara",
    "href": "wg_facilitation.html#visiting-santa-barbara",
    "title": "Meeting Facilitation & Santa Barbara Tips",
    "section": "Visiting Santa Barbara",
    "text": "Visiting Santa Barbara\nWhen your group is visiting at NCEAS’ office in beautiful Santa Barbara there are additional resources available to your group and opportunities for recreation and bonding as a team! Check out NCEAS’ general computing resources page for a quick rundown of some resources available only in Santa Barbara (including how to get on the WiFi!).\nWe very much recommend taking an afternoon or morning on one of the days of your visit to get out and explore Santa Barbara! NCEAS’ page for things to do in SB for new employees might prove to be a helpful resource for you and your group as you’re deciding where to eat and what to do!"
  },
  {
    "objectID": "modules_tutorials/quarto-website_add-content.html",
    "href": "modules_tutorials/quarto-website_add-content.html",
    "title": "LTER Scientific Computing Team",
    "section": "",
    "text": "Now that you have a live website you can build whatever you’d like! Given the wide range of possibility, we’ll only cover how to add a new page but the same process applies to any edit to the living webpage.\nTo add a new page create a new Quarto document. You can do this by going to the “File” menu, entering the “New File” options, and selecting “Quarto Document…”\n\n\n\nSimilarly to an R markdown file, this will open a new window that lets you enter a title and author as well as decide what format you want to render files to along with some other settings options. You only need to click the “Create” button in the bottom right of this dialogue (though you can definitely play with the other options and text boxes as you desire).\n\n\n\nAfter a moment, a new .qmd file will open in Quarto’s visual editor. For the purposes of this tutorial, you only need to add a title in the top of the file but for a real website you can add whatever content sparks joy for you!\n\n\n\nSave that file into your project folder. Its name can be anything but be sure that you remember what you name it!\n\n\n\nAdd the name of the new Quarto document to the .yml file in the website navbar area (in this example the file is called “more-stuff.qmd”).\n\n\n\nOnce you’ve added the file to the fundamental architecture of your website, you need to tell Quarto to re-build the part of the website that GitHub looks for when it deploys. To do this run quarto render in the Terminal.\nIf you want to preview your changes, run quarto preview in the Terminal and a new browser window will be displayed showing your current website content. This preview continues until you click the red stop sign icon in RStudio so be sure to end it when you’re done with the preview!\n\nRegardless, once you’ve run either quarto render or quarto preview you need to stage and commit all changed files indicated in the Git pane of RStudio. As a reminder, to stage files you check the box next to them, to commit staged files, type an informative message and press the “Commit” button in the right side of the window.\n\nSwitch back to GitHub and you’ll see an amber dot next to the commit hash just beneath and to the left of the green “Code” button.\n\nWhen the amber dot turns into a green check mark that means that your edits to your website are now included in the live version of your site!\n\nWhen you visit your website you may need to refresh the page for your edits to appear but all new visitors will see the updated content when they load the page."
  },
  {
    "objectID": "modules_tutorials/github-create.html",
    "href": "modules_tutorials/github-create.html",
    "title": "LTER Scientific Computing Team",
    "section": "",
    "text": "From your GitHub “Repositories” tab, click the  green  “New” button.\n\nAdd a title to your repository and add a description. Once you’ve added these two things, scroll down and click the  green  “Create repository” button.\n\n\n\nBe sure that you do not add a README, do not add a gitignore, and do not add a license. Adding any of these three will cause a merge conflict when we link the project that you just created with the GitHub repository that you are in the process of creating.\n\n\n\nAfter a few seconds you should be placed on your new repository’s landing page which will look like the below image because there isn’t anything in your repository (yet).\nCopy the link in the field and go back to your RStudio session."
  },
  {
    "objectID": "modules_tutorials/github-website-deploy.html",
    "href": "modules_tutorials/github-website-deploy.html",
    "title": "LTER Scientific Computing Team",
    "section": "",
    "text": "In order to get your new website actually on the web, we’ll need to tell GitHub that we want our website to be accessible at a .github.io URL.\nTo do this, go to the “Settings” tab with a gear icon and click it. You may be prompted to re-enter your GitHub password, do so and you can proceed.\n\nIn the resulting page, look towards the bottom of the left sidebar of settings categories and click the “Pages” option. This is at the very bottom of the sidebar in the screen capture below but is towards the middle of all of the settings categories Github offers you.\n\nScroll down to the middle of this page and where it says “Branch” click the dropdown menu that says “None” by default.\n\nSelect “main” from the dropdown.\n\n\n\nThis opens up a new dropdown menu where you can select which folder in your repository contains your website’s content (it defaults to “/ (root)”). Because we specified output-dir: docs in the .yml file earlier we can select “/docs” from the dropdown menu.\n\n\n\nOnce you’ve told GitHub that you want a website generated from the “docs” folder on the main branch, click the “Save” button.\n\n\n\nFrom this moment your website has begun being deployed by GitHub! You can check the status of the building process by navigating to the “Actions” tab of your repository.\nSelect the “pages build and deployment workflow” in the list of workflows on the bottom righthand side of the page.\n\nThis shows you GitHub’s building and deployment process as a flowchart. While it is working on each step there will be an amber circle next to the name of that sub-task. When a sub-task is completed, the amber circle becomes a green circle with a check mark.\n\nWhen the three steps are complete the amber clock symbol next to the “pages build and deployment” action will turn into a larger green circle with a check mark. This is GitHub’s way of telling you that your website is live and accessible to anyone on the internet.\n\nYou can now visit your website by visiting its dedicated URL. This URL can be found by returning to the “Settings” tab and then scrolling through the sidebar to the “Pages” section.\nAlternately, the website for your repository always uses the following composition: https://repository owner.github.io/repository name/\n\nIf we visit that link, we can see that our website is live!\n\n\nGitHub Housekeeping\nWe recommend a quick housekeeping step now to make it easier to find this URL in the future. Copy the URL from the Pages setting area and return to the “Code” tab of the repository.\nOnce there, click the small gear icon to the right of the “About” header.\n\nIn the resulting window, paste the copied URL into the “Website” field. Once you’ve pasted it in, click the green “Save changes” button.\n\n\n\nThis places the link to your deployed website in an intuitive, easy-to-find location both for interested third parties and yourself in the future."
  },
  {
    "objectID": "modules_tutorials/googledrive-auth.html",
    "href": "modules_tutorials/googledrive-auth.html",
    "title": "LTER Scientific Computing Team",
    "section": "",
    "text": "In order to connect R with a GoogleDrive, we’ll need to authorize googledrive to act on our behalf. This only needs to be done once (per computer) so follow along and you’ll be building GoogleDrive into your workflows in no time!\nFirst, install the googledrive and httpuv R packages. The googledrive package’s need is self-evident while the httpuv package makes the following steps a little easier than googledrive makes it alone. Be sure to load the googledrive package after you install it!\n\n# Install packages\ninstall.packages(c(\"googledrive\", \"httpuv\"))\n\n# Load them\nlibrary(googledrive)\n\nOnce you’ve installed the packages we can begin the authentication in R using the drive_auth function in the googledrive package.\n\ngoogledrive::drive_auth(email = \"enter your gmail here!\")\n\nIf this is your first time using googledrive, drive_auth will kick you to a new tab of your browser (see below for a screen grab of that screen) where you can pick which Gmail you’d like to connect to R.\n\n\n\nClick the Gmail you want to use and you will get a second screen where Google tells you that “Tidyverse API” wants access to your Google Account. This message is followed by three checkboxes, the first two are grayed out but the third is unchecked.\n\n\n\n\n\n\n\n\n\nNOTE\n\n\n\nThis next bit is vitally important so carefully read and follow the next instruction!\n\n\nIn this screen, you must check the unchecked box to be able to use the googledrive R package. If you do not check this box all attempts to use googledrive functions will get an error that says “insufficient permissions”.\n\n\n\nWhile granting access to “see, edit, create, and”delete” all of your Google Drive files” sounds like a significant security risk, those powers are actually why you’re using the googledrive package in the first place! You want to be able to download existing Drive files, change them in R on your computer, and then put them back in Google Drive which is exactly what is meant by “see, edit, create, and delete”.\nAlso, this power only applies to the computer you’re currently working on! Granting access on your work computer allows only that computer to access your Drive files. So don’t worry about giving access to your Drive to the whole world, that is protected by the same failsafes that you use when you let your computer remember a password to a website you frequent.\nAfter you’ve checked the authorization box, scroll down and click the “Continue” button.\n\n\n\nThis should result in a plain text page that tells you to close this window and return to R. If you see this message you are ready to use the googledrive package!"
  },
  {
    "objectID": "tutorial_json.html",
    "href": "tutorial_json.html",
    "title": "LTER Scientific Computing Team",
    "section": "",
    "text": "Working groups sometimes need to handle user-specific information in their code. For example, if your group stores your data in the cloud (e.g., in Box, in Dropbox, etc.) each user will have a different “absolute file path” to the synced version of the data folder on their personal computer. Similarly, groups may find it valuable to use their email address in the code. While you could simply have each group member add their information (file path, email, etc.) and comment out all but one of them when you work in that script, there is a better option: user-specific JSON files!\nThe main advantage of this method is that you and your group members do not have to manually change any user-specific information in scripts just because a different person runs them!\n\nPrerequisites\nTo follow along with this tutorial you will need to take the following steps:\n\nDownload R\nDownload RStudio\nInstall the jsonlite R package\n\nFeel free to skip any steps that you have already completed!\n\n\n1. Create the JSON\nFirst, you’ll need to use RStudio to create your JSON file by creating a new text file (in the top left of RStudio click “File”  “New File”  “Text File”). In the new text file, add content that looks like this:\n\n{\n  \"email\":\"my_email@gmail.com\"\n  \"dropbox_path\":\"path/to/dropbox-sync/for/me\"\n}\n\nReplace the content on the right of the colon with your actual information. If desired, you can add as many other pieces of user-specific information as you’d like! Simply follow the \"info name\":\"info content\" format and make sure that each piece of information is on its own line.\nOne small note here for when you work with your group: all group members need to use exactly the same name to the left of each colon.\nYou’ll see later when we show an example of this but you can think of the information on the left of the colon as comparable with a column name. It doesn’t matter that the text in the “rows” will differ between users as long as the script has a consistent “column” in which to look for that text.\n\n\n2. Save the JSON with a Consistent Name\nThis may seem self-evident but all group members need to use the same file name for this new JSON file. We recommend user.json if you are undecided. This will let scripts that refer to the JSON use the same file name regardless of which user is running the code (same spirit as using consistent names for each piece of information in the file.)\n\n\n3. Tell Git to Ignore the JSON\nIf you’re using version control for your project (which we strongly recommend!), you’ll want Git to ignore the fact that this file differs for each user. Navigate to the .gitignore file of your project and put in the name of your JSON file as one of the files to ignore. We don’t want to push the JSON to GitHub since each person’s file will look different (that is our intent after all) and you wouldn’t want to accidentally overwrite your teammate’s user-specific information or cause a merge conflict.\nFor a deeper dive into the .gitignore check out that module of our “Collaborative Coding with GitHub” workshop!\n\n\n4. Benefit from the JSON!\nIf you’ve made it through the preceding steps, you can now use the information you stored in the JSON file. You’ll need to use the jsonlite R package to read in your file but once you’ve done that, you can access the information inside of it in classic R fashion.\nSee an example below:\n\n# Load needed library\nlibrary(jsonlite)\n\n# Read in the JSON file\nuser_info &lt;- jsonlite::read_json(\"user.json\")\n\n# Grab the file path out of it\ndropbox &lt;- user_info$dropbox_path\n\n# Use it as you would any other file path\nmy_data &lt;- read.csv(file = file.path(dropbox, \"2024_data.csv\"))\n\nNow everyone in your group can use the same script because their personal file paths are readily accessible without needing to be hard-coded! The same theory applies to any other piece of information your group finds it valuable to store in the JSON.\n\nHelp with Absolute File Paths\nIdentifying and manually writing out an absolute file path can be cumbersome so we’ve found a nice work-around (at least for Mac users) that you may find useful. First, in Finder, navigate to the last folder in the file path you’d like to preserve. In the row of folder names in the bottom of the Finder window, right-click the folder name and select “Copy ‘&lt;folder name&gt;’ as Pathname”.\nOnce you’ve done that, you can simply paste the file path into your JSON file."
  },
  {
    "objectID": "tutorial_server.html",
    "href": "tutorial_server.html",
    "title": "Server Tutorial",
    "section": "",
    "text": "Working on NCEAS’ Server is similar to working on an entirely separate computer from the laptop or desktop computer on which you typically work. This means that you need to go through the steps of connecting GitHub to your “RStudio” again for the instance of RStudio accessed through Aurora. GitHub’s Personal Access Token is referred to as “token” hereafter for simplicity. Note that our server also runs other analytical tools such as JupyterHub for python users.\nOften the reason to engage with the server is to increase the scale of your analyses far beyond what your personal computer can handle. There are other advantages such as:\n\nStorage Capacity – More disk space & faster storage\nComputing Power – More CPUs & RAM (384GB!!)\nSecurity – Nightly backups and data are distributed across multiple drives\nCollaboration – Shared data & consistent software versions accessible to everyone on your team"
  },
  {
    "objectID": "tutorial_server.html#overview",
    "href": "tutorial_server.html#overview",
    "title": "Server Tutorial",
    "section": "",
    "text": "Working on NCEAS’ Server is similar to working on an entirely separate computer from the laptop or desktop computer on which you typically work. This means that you need to go through the steps of connecting GitHub to your “RStudio” again for the instance of RStudio accessed through Aurora. GitHub’s Personal Access Token is referred to as “token” hereafter for simplicity. Note that our server also runs other analytical tools such as JupyterHub for python users.\nOften the reason to engage with the server is to increase the scale of your analyses far beyond what your personal computer can handle. There are other advantages such as:\n\nStorage Capacity – More disk space & faster storage\nComputing Power – More CPUs & RAM (384GB!!)\nSecurity – Nightly backups and data are distributed across multiple drives\nCollaboration – Shared data & consistent software versions accessible to everyone on your team"
  },
  {
    "objectID": "tutorial_server.html#server-workflow",
    "href": "tutorial_server.html#server-workflow",
    "title": "Server Tutorial",
    "section": "Server Workflow",
    "text": "Server Workflow\nBefore diving into the process of getting set up on and using the server, it will be helpful to briefly consider what a workflow involving the server “looks” like! When you are working on the server you will need to consider what is stored on your personal computer (bottom left), on GitHub (bottom right), and on NCEAS’ server (top).\nTo simplify, let’s focus on (1) where your data live and (2) where your code lives.\n\n\n\n\nData\nYour data (or at least some of it) is likely on your personal computer. Those specific files are only accessible to you and you almost certainly have a file path to those data (i.e., levels of nested folders) that is unique to you. Even if you share the data file with someone on your team–via email or a cloud storage device–they will likely have to tweak any code that you share to ensure that the file paths are correct for their computer.\nWhen you involve the server, all of your group’s data can live in a folder on the server within the shares folder. Only your group will have access to the data in that subfolder of shares . A huge advantage of this is that everyone in your group will now have the exact same file path to the data while working on the server.\nThis means that there is no chance that you can be working in the “wrong” version of the data (i.e., one that is outdated, doesn’t reflect new metadata, etc.) because everyone is using the exact same file(s) rather than emailing static copies of data that may become outdated without warning.\n\n\nCode\nWe strongly recommend that you use GitHub to manage your code to streamline the use of either the server or your personal computer while collaborating with other group members.\nIf you are unfamiliar with git, it is a “version control system” that allows line-by-line tracking of changes to code. GitHub add features to git to enable multiple people to share and work on the same code which is very useful in collaborative contexts like working groups. Git and GitHub are not really meant to track or store data (though it can do this in a somewhat limited way) so notice that the yellow “Data” folder is absent from the bottom right part of the triangle. We offer an entire workshop on GitHub that we are happy to offer to your group if that is of interest so just let us know!\nAssuming that you use GitHub, your code (and its history) will be preserved there. You can then write or edit code either on your personal computer or on the server. Regardless of where you make the changes, so long as you connect both your personal computer and your server profile to your GitHub account, you will have a centralized place for all of your code that is accessible to both workspaces.\nNotice that on the server, your code will be in your subfolder of the home folder on the server. Only you can access this folder and you will be leveraging GitHub to share your code with others! This means that everyone in your group can have their own code files while every copy of those scripts can use the file path in the shares folder to access the data files. In other words, use GitHub to share your code stored in your home folder and your group shared folder to share data.\nA final advantage in the ‘code’ realm is that the server has a consistent version of R, RStudio, and git (the program underpinning GitHub) so there is no chance that a software version difference can affect different members of your group differently."
  },
  {
    "objectID": "tutorial_server.html#getting-set-up",
    "href": "tutorial_server.html#getting-set-up",
    "title": "Server Tutorial",
    "section": "Getting Set Up",
    "text": "Getting Set Up\n\nNecessary Software\nThe only software that you will need on your personal computer to get set up on NCEAS’ server is RStudio!\nYou likely have worked in the “Console” tab of RStudio (where run lines and outputs appear; see below) but RStudio has another tab to the right of the “Console” called “Terminal” which offers RStudio users access to the command line (a.k.a. the shell). If you are a veteran command line user you may prefer to use the standalone Terminal app on MacOS or PuTTY on Windows but for the sake of keeping your tool kit streamlined, we’ll walk through getting set up on NCEAS’ server using only RStudio’s Terminal tab.\n\n\n\nThe Terminal does not accept R syntax (and the Console doesn’t accept Terminal syntax) so you may notice that some of the code we’ll walk you through below is formatted differently than you would write an R script.\n\n\n\n\n\nGet Invited!\nIn order to access the server (and follow the instructions below) we’ll need to create an account on the server for you. Please email someone on our team or scicomp@nceas.ucsb.edu so that we can contact NCEAS’ IT team and get an invite email sent to you.\nIn that email, please include the name and email addresses of all of your team members who want to access the server. After that information has been received, NCEAS’ IT team will create accounts for all of those people and will send you an invitation email to set up your account on the server.\nAn example of what that email may look like is included below but there are two key pieces of information:\n\nYour username\nYour temporary password (covered by a red bar in the screenshot).\n\nIf you have not received that email, check your Spam folder for emails from Thomas Hetmank (hetmank@nceas.ucsb.edu) or Nick Outin (outin@nceas.ucsb.edu). If you have not received the email and it is not in your Spam, reach out to our team and we will work to get an invite sent to you.\n\n\n\n\n\nSetting your Password\n\nNote on this Step of the Set Up\nNote that you only have to set your password once! For security, when we create your account on the server we create a temporary password that can only be used once (see the invite email screenshot above). So, when you first login to the server by following the instructions below, you’ll need to create a “real” (i.e., non-temporary) password. Subsequent sign-ins to the server do not require this ‘Setting your Password’ section at all!\nIn the following instructions we use text formatting to explain what you should type.\n\nText like this should be typed into the Terminal tab of Rstudio\n\n\nRun it by pressing “enter” or “return”\nNote that typing these commands into an R script or R Markdown will not work because it will attempt to run in the Console rather than the Terminal\n\n\nText wrapped by brackets [like this] should also be typed in the Terminal tab BUT you should replace the text in brackets in a user-specific way that is clarified in the nearby text\n\n\n\nPassword Setting Instructions\n\nIn the Terminal pane of RStudio, you will “ssh” into the server by running the following code: ssh [your username]@aurora.nceas.ucsb.edu. It is “@aurora” because the name of the server is Aurora.\nYou will need to enter yes to accept the server’s SSH key.\nYou will then be prompted to enter your [temporary password] (see the above email example). Note that the cursor will not advance as you type but it is registering your entries! There will be no indication that you are typing (such as: “•••••••••”). This throws off many users so hopefully this note helps set your mind at ease!\n\nNext, you will be prompted to change your “expired” password. We consider your temporary password to be expired as soon as you use it because sharing passwords via email is not secure and this “expiration” lets you set the password to something that only you know at the outset of your time in the server. Note again that the cursor will not advance as you type but it is working!\n\nTo update your password, (i) enter your [temporary password], then (ii) [your strong new password] and finally (iii) re-type [your strong new password] to confirm it. Note that your new password should not be “your strong new password” \nYou are all set up! Run exit to log out of the server in the Terminal tab."
  },
  {
    "objectID": "tutorial_server.html#accessing-the-server",
    "href": "tutorial_server.html#accessing-the-server",
    "title": "Server Tutorial",
    "section": "Accessing the Server",
    "text": "Accessing the Server\n\nUse your favorite web browser (e.g., Firefox, Chrome, etc.) to access Aurora at aurora.nceas.ucsb.edu and click “Login to RStudio Server”\n\n\n\n\n\nSign in with your username and the password that you created in the “Getting Set Up” section of this tutorial.\n\n\n\n\nYou should now be in something that looks very much like RStudio but is housed in a tab on your browser!\n\n\n\nIf the above steps have not resulted in successfully accessing Aurora, consult NCEAS’ instructions on first login and/or SSH-specific instructions for Mac vs. Windows and/or email us!"
  },
  {
    "objectID": "tutorial_server.html#connecting-github",
    "href": "tutorial_server.html#connecting-github",
    "title": "Server Tutorial",
    "section": "Connecting GitHub",
    "text": "Connecting GitHub\nAs stated at the beginning of this tutorial, we cannot overstate how strongly we suggest integrating GitHub into your collaborative coding process. We are happy to work through our GitHub tutorial if that is of interest though you may find walking through the materials at your own pace helpful even without a formal workshop!\nWhen setting up git/GitHub on your personal computer, you normally have to install R, RStudio, git, and make an account on GitHub. When working on the server, R, RStudio, and git are already successfully installed and ready for you to use. So, to begin connecting your server profile with GitHub you need only follow these steps:\n\nCreate a GitHub account using the web browser of your choosing.\nInstall and load the usethis and gitcreds packages\n\n\ninstall.packages(c(\"usethis\", \"gitcreds\"))\nlibrary(usethis); library(gitcreds)\n\n\nTell the server your GitHub username and email\n\n\nusethis::use_git_config(user.name = \"Your GitHub Username\",\n                        user.email = \"Your GitHub Email\")\n\n4A. Create a Personal Access Token (PAT) on GitHub for your server profile. Note: running the below line of code will open a browser window for you to create a token on GitHub! For additional information, see GitHub’s PAT Tutorial or the Happy Git with R PAT Tutorial.\n\nusethis::create_github_token()\n## Be sure to copy the token when you're done!!!\n## It will be a long string of letters and numbers\n\n4B. Before you navigate away from the token page, copy the token and paste it somewhere safe for the rest of these setup instructions. If you close or leave the window without copying the token, you will not be able to see the token again so you’d have to make a new one to complete the next step.\n\nNext, give your server profile the token you just created! Running the below line of code will prompt you to paste your token into the Console and hit enter. Note that your token should not be in quotes when you give it to the Console.\n\n\ngitcreds::gitcreds_set()\n\nAt the end of the above steps your token should be set! You should now be able to interact with code that you can access on GitHub directly from the server.\n\nFinally, in the Terminal pane of RStudio you need to tell the server to “remember” your token for some set amount of time.\n\n\ngit config --global credential.helper 'cache --timeout=10000000'\n\nThe timeout bit of that argument is the amount of time in minutes you want your token to be remembered. You can’t set it to remember your token forever so 10 million minutes (just over 19 years) should be long enough that you don’t need to worry about this again."
  },
  {
    "objectID": "tutorial_server.html#uploading-data",
    "href": "tutorial_server.html#uploading-data",
    "title": "Server Tutorial",
    "section": "Uploading Data",
    "text": "Uploading Data\n\nVia RStudio\nIf you are uploading a single file, it may be most convenient to use RStudio’s data upload capabilities. In the “Files” pane (default is top right but it may differ on your computer), you can click the button that is a white rectangle with a yellow circle with an upward facing arrow inside of it. In the below image the relevant button is in a red square.\n\n\n\nClicking that button allows you to choose (1) where you want the uploaded file to go and (2) which file you want to upload.\n\n\n\nYou can also download data via the RStudio interface. To download a file, check the box next to it in the “Files” pane.\n\n\n\nOnce the box is checked, click the gear icon then click the “Export…” option (about halfway down). In the image below this option is surrounded by a red square\n\n\n\nIn the resulting box you can choose to rename the file before downloading to your local computer. After renaming the file (or keeping its original name), click the “Download” button and the download should begin after a moment.\n\n\n\nThese methods are effective for one or a few files being up/downloaded to the same directory but can quickly become cumbersome if you want to handle many files or a few files to several different folders.\n\n\nVia sFTP Software\nIf you want to upload or download many files we recommend using sFTP software (secure File Transfer Protocol). We use Cyberduck internally, though there are alternatives like WinSCP. Both programs are free to use and more than capable of uploading and download many files to/from the server quickly and easily.\nOnce you have installed one of these programs, you can sign in to the server from the sFTP program using your server username and password and can then upload or download files from your personal computer in the same way as you would move files among folders within your personal computer.\n\nCyberduck Set Up Tutorial\nHere we briefly demonstrate how to set up a connection between Cyberduck and NCEAS’ Server. Note that you must have already installed Cyberduck to follow these steps.\n\nIn the Cyberduck window, click the “Open Connection” button with an icon of a globe with a plus sign. In the below image the button has a red square around it.\n\n\n\n\n\nIn the resulting window, input the following information:\n\n“Server” – “aurora.nceas.ucsb.edu”\n“Username” – whatever your username on the server is\n“Password” – your password to the server\n“Port” – change it to “22” (it will start as “21”)\n\n\n\n\n\n\nAlso, click the dropdown menu at the top that says “FTP (File Transfer Protocol) and select”SFTP (SSH File Transfer Protocol)” from the set of available options.\n\n\n\n\n\nOnce you’ve input the above information, click the “Connect” button and you should have access to the server! You can now click around the different folders you have access to and upload or download from there.\n\n\nTo download: click the files/folders that you want and they should begin downloading to your personal computer\nTo upload: drag and drop the files where you want them\n\n\n\n\nVia the Command Line\nIf you are more comfortable with a CLI (Command Line Interface) you can also use that method of uploading/downloading. The command line includes the Terminal pane in RStudio, Terminal app for Macs, PuTTY, and gitBash among others. CLI can be a great tool to leverage filenames or types to filter specific files you would like to upload / download. Text in code chunks below are command line commands and any bracketed text [like this] should be replaced by some user-specific information before running.\nThis portion of the tutorial is focused on using the command line to interact with the server. That said, if you’re interested in the command line more generally or for other purposes, please reach out to our team!\n\nCLI Option A: scp\nThe scp command can be used to upload a file or folder from your computer to the server.\n1A. Navigate to the folder on your computer containing the file(s) you want to upload\n\ncd [folder]\n\n\nNote that if the folder name has spaces you’ll need to “escape” the space by using a backslash (\\)\n\n\ncd [folder\\ name]\n\n2A. Now you can upload that file to the server!\n\nscp [file_name] [user]@aurora.nceas.ucsb.edu:/[path/to/destination_folder/]\n\nIf instead you’d like to upload all of the files in a folder, do the following:\n1B. Navigate to the folder containing the folder on your computer you want to upload (using cd)\n\ncd [folder]\n\n2B. Use scp with the recursive option (-r) to upload all of the files in that folder\n\nscp -r [folder] [user]@aurora.nceas.ucsb.edu:/[path/to/destination_folder/]\n\n\nNote that this uploads all of the files in the folder not the folder itself so you may want to create a new folder on the server to upload your local folder’s contents into.\n\nFinally, note that you can also download files from the server to your local machine by simply switching the order of the machines:\n\nscp [user]@aurora.nceas.ucsb.edu:/[path/to/server_folder/file_name] [local_folder] \n\n\n\nCLI Option B: sftp\nThe get command can be used to download a file.\n\nConnect to the server\n\n\nsftp [user]@aurora.nceas.ucsb.edu:/home/shares\n\nYour prompt at the shell should now have switched to sftp&gt; and although it is the same window you are now looking at the files on the server! Try it by typing the ls command at the prompts. This will list all the files and folders within the shares folder on Aurora.\n\nEnter your group’s folder in the shares folder\n\n\ncd [your_group_folder]\n\n\nIf needed, continue using cd to get to the subfolder you want to access. Remember to “escape” any spaces in the folder name with backslashes!\n\n\ncd [subfolder]\n\nNote that most of the bash command will work, so you can use ls to list files and pwd to check your current path.\n\nWhen you are in the folder containing the file(s) you want, download the file you want\n\n\nget [file_name_server]\n\n\nYou can also upload a local file to the server by using the put sFTP command\n\n\nput [file_name_local]\n\n\nWhen you are done downloading, close the connection to the server\n\n\nexit"
  },
  {
    "objectID": "staff.html",
    "href": "staff.html",
    "title": "Our Team",
    "section": "",
    "text": "Because we live in an era where we may only meet in person sporadically, we felt it would be nice to introduce ourselves here to help you put a face to the emails / Slack messages / GitHub issues we exchange going forward! If you would like to email the whole team as one send your questions to scicomp [at] nceas.ucsb.edu"
  },
  {
    "objectID": "staff.html#past-team-members",
    "href": "staff.html#past-team-members",
    "title": "Our Team",
    "section": "Past Team Members",
    "text": "Past Team Members\nWe have been privileged to work with the following teammates who have since gone on to other positions.\n\nJulien Brun (he/him)\n brunj7.github.io –  brunj7 –  @brunj7\n\nJulien was responsible for mentoring the other members of the scientific computing support team as well as advising researchers on how best to address their data challenges with scripted, reproducible solutions. Julien now works for the UCSB Library team as a research facilitator in the earth and environmental sciences. Julien is also a Lecturer in the Master in Environmental Data Science program at Bren School of Environmental Science and Management at UC Santa Barbara, where he teaches “good enough” practices in reproducible and collaborative data science."
  },
  {
    "objectID": "index.html#what-we-do",
    "href": "index.html#what-we-do",
    "title": "LTER Scientific Computing Team",
    "section": "What We Do",
    "text": "What We Do\nThe Scientific Computing team is a small (but mighty!) team of data scientists supporting synthesis working groups funded by the Long Term Ecological Research (LTER) Network Office. Participation in these groups is open to scientists from within and outside of the LTER Network. We provide modern technological infrastructure to support analytical, computing, or network-based needs for these synthesis working groups.\nWe are housed at the National Center for Ecological Analysis and Synthesis (NCEAS). Our goal is to support and promote an open and reproducible approach to synthesis science. We do so by providing on-demand training, advising, and direct code/data support. In addition to the support during in-person meetings at NCEAS, our team is available in-between visits to discuss and advise on data science and scientific programming tasks, such as:\n\nStructuring and integrating heterogeneous datasets\nWriting code to wrangle, analyze, model, or visualize the data your group has already collected\nDesigning workflows, scripting best practices for reproducible science, and reviewing code\nHelping you get set up on NCEAS’ server and scale your analysis\nPreserving and promoting your products on the internet\n\nIncluding everything from derived datasets and terminological glossaries/vocabularies to scripts, model codes, and interactive “web applications”\n\nOffering workshops on new skills or programs (such as Git/GitHub)\n\nDepending on your team’s preferences, we can operate on a spectrum of independence ranging from complete self-sufficiency after initial definition of task scope to coding together with your team.\nContact our team with your requests at scicomp [at] nceas.ucsb.edu"
  },
  {
    "objectID": "index.html#navigating-this-website",
    "href": "index.html#navigating-this-website",
    "title": "LTER Scientific Computing Team",
    "section": "Navigating this Website",
    "text": "Navigating this Website\n\nWorking Group MembersOther Visitors\n\n\nFor members of our working groups, this website is a centralized hub of resources designed to help you get familiar with the way our team works and what we offer. The pages under the Working Group Onboarding dropdown menu are particularly targeted at facilitating collaboration between your group and our team!\n\n\nWelcome! Even if you’re not a part of a working group, we hope that you find the various resources on this website helpful! If you’re interested in learning more about open, reproducible science, please feel free to take a look at our Workshops pages and Coding Tips pages for other useful tips in R.\n\n\n\n\n\n\nLTER All Scientists’ Meeting 2022, Pacific Grove CA"
  },
  {
    "objectID": "workshops.html",
    "href": "workshops.html",
    "title": "Workshops",
    "section": "",
    "text": "In addition to the specific task-based support we offer, we can also create and run interactive workshops on data or coding topics. The specific goals of these workshops can be modified to best suit your team and meet all attendees where they are to ensure no one is left behind. While we are always happy to discuss developing new workshops we do have some materials that have already been designed (and tested by other working groups!) and are happy to offer any of these workshops to your group if it is of interest."
  },
  {
    "objectID": "workshops.html#collaborative-coding-with-github",
    "href": "workshops.html#collaborative-coding-with-github",
    "title": "Workshops",
    "section": "Collaborative Coding with GitHub",
    "text": "Collaborative Coding with GitHub\n\nWorkshop Website\n\nIn synthesis science, collaboration on code products is often integral to the productivity of the group. However, learning to use the software and graphical user interfaces that support this kind of teamwork can be a significant hurdle for teams that are already experts in their subject areas. This workshop is aimed at helping participants gain an understanding of the fundamental purpose and functioning of “version control” systems–specifically GitHub–to help teams more effectively code collaboratively.\nThe GitHub  repository for the workshop can be found here."
  },
  {
    "objectID": "workshops.html#coding-in-the-tidyverse",
    "href": "workshops.html#coding-in-the-tidyverse",
    "title": "Workshops",
    "section": "Coding in the tidyverse",
    "text": "Coding in the tidyverse\n\nWorkshop Website\n\nFor teams that code using the R programming language, the most familiar tools are often part of “base R” meaning that those functions and packages come pre-loaded when R is installed. Relatively recently the tidyverse has emerged as a comprehensive suite of packages that can complement base R or serve as an alternative for some tasks. This includes packages like dplyr and tidyr as well as the perhaps infamous pipe operator (%&gt;%) among many other tools. This workshop is aimed at helping participants use the tidyverse equivalents of fundamental data wrangling tasks that learners may be used to performing with base R.\nThe GitHub  repository for the workshop can be found here."
  },
  {
    "objectID": "workshops.html#r-shiny-apps-for-sharing-science",
    "href": "workshops.html#r-shiny-apps-for-sharing-science",
    "title": "Workshops",
    "section": "R Shiny Apps for Sharing Science",
    "text": "R Shiny Apps for Sharing Science\n\nWorkshop Website\n\nOne of our team members–Nick Lyon–created a workshop on learning to create R Shiny apps. R Shiny includes a suite of R packages (primarily shiny) that allow R users to create interactive apps that can be subsequently deployed to a URL. These apps are most commonly used for data visualization purposes but can also be a neat way of accomplishing other outward-facing tasks without needing to learn a new programming language. This workshop was offered at the 2022 LTER All Scientists’ Meeting (ASM) and is aimed at an audience with moderate R capability but limited prior exposure to Shiny.\nThe GitHub  repository for the workshop can be found here.\nThis workshop also includes a second GitHub  repository that contains several example Shiny apps. See here."
  },
  {
    "objectID": "workshops.html#other-training-resources",
    "href": "workshops.html#other-training-resources",
    "title": "Workshops",
    "section": "Other Training Resources",
    "text": "Other Training Resources\n\nNCEAS Learning Hub\n\n\nTraining Catalog\n\nIn addition to the workshops described above, NCEAS offers a variety of other workshops and trainings that may be of interest to you or your group via the Learning Hub. While these trainings can be very helpful, it is important to note that our team may or may not be involved with teaching them. Also, workshops we create will be hosted on this website rather than on the Learning Hub.\n\n\nThe Carpentries\n\nThe Carpentries is another great place to find workshops and tutorials on various data and programming topics. All of their materials are publicly available so even if a workshop isn’t being offered, you can visit that site and review the content at your own pace! This can be a nice way of refreshing yourself on the fundamentals of something you have prior experience with or teaching yourself something totally new! For example, the Carpentries include helpful workshops on using R for ecologists, using the “shell” or command line, or handling geospatial data in R.\nFor the set of lessons that are most likely to be helpful to your groups, explore the Data Carpentry and Software Carpentry lesson lists."
  }
]